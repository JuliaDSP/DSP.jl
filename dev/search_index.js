var documenterSearchIndex = {"docs":
[{"location":"windows/#Windows-window-functions","page":"Windows - window functions","title":"Windows - window functions","text":"","category":"section"},{"location":"windows/","page":"Windows - window functions","title":"Windows - window functions","text":"rect\nhanning\nhamming\ntukey\ncosine\nlanczos\ntriang\nbartlett\ngaussian\nbartlett_hann\nblackman\nkaiser\ndpss\ndpsseig","category":"page"},{"location":"windows/#DSP.Windows.rect","page":"Windows - window functions","title":"DSP.Windows.rect","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▘│ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nrect(n::Integer; padding::Integer=0, zerophase::Bool=false)\nrect(dims; padding=0, zerophase=false)\n\nRectangular window of length n, padded with padding zeros. This window is 1 within the window, and 0 outside of it.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.hanning","page":"Windows - window functions","title":"DSP.Windows.hanning","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                             ▗▄▞▀▀▀▀▀▀▀▄▄                             │ \n  │                           ▄▞▘           ▀▄▖                          │ \n  │                         ▄▀                ▝▚▖                        │ \n  │                       ▗▞                    ▝▄                       │ \n  │                      ▞▘                      ▝▚▖                     │ \n  │                    ▗▀                          ▝▚                    │ \n  │                   ▞▘                             ▀▖                  │ \n  │                 ▗▞                                ▝▄                 │ \n  │                ▄▘                                   ▚▖               │ \n  │              ▗▞                                      ▝▄              │ \n  │             ▄▘                                         ▚▖            │ \n  │           ▗▀                                            ▝▚           │ \n  │         ▗▞▘                                               ▀▄         │ \n  │       ▄▀▘                                                   ▀▚▖      │ \n0 │ ▄▄▄▄▀▀                                                        ▝▀▚▄▄▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nhanning(n::Integer; padding::Integer=0, zerophase::Bool=false)\nhanning(dims; padding=0, zerophase=false)\n\nHanning window of length n with padding zeros. The Hanning (or Hann) window is a raised-cosine window that reaches zero at the endpoints.\n\nThe window is defined by sampling the continuous function:\n\n       1 + cos(2πx)\nw(x) = ──────────── = cos²(πx)\n            2\n\nin the range [-0.5, 0.5]\n\nThe hanning window satisfies the Constant Overlap-Add (COLA) property with an hop of 0.5, which means that adding together a sequence of delayed windows with 50% overlap will result in a constant signal. This is useful when synthesizing a signal from a number of overlapping frames (each with a roughly rectangular window), to eliminate windowing amplitude modulation.\n\nNote that the hanning window is the cosine window squared.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.hamming","page":"Windows - window functions","title":"DSP.Windows.hamming","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                             ▗▄▀▀▀▀▀▀▀▀▚▄                             │ \n  │                           ▄▀▘           ▀▚▖                          │ \n  │                         ▞▀                ▝▀▖                        │ \n  │                       ▄▀                    ▝▚                       │ \n  │                     ▗▀                        ▀▚                     │ \n  │                   ▗▞▘                           ▀▄                   │ \n  │                  ▄▘                               ▚▖                 │ \n  │                ▗▞                                  ▝▄                │ \n  │               ▞▘                                     ▀▖              │ \n  │             ▄▀                                        ▝▚▖            │ \n  │           ▗▞                                            ▝▄           │ \n  │         ▄▞▘                                               ▀▄▖        │ \n  │      ▗▄▀                                                    ▝▚▄      │ \n  │ ▄▄▄▞▀▘                                                         ▀▀▄▄▄▖│ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nhamming(n::Integer; padding::Integer=0, zerophase::Bool=false)\nhamming(dims; padding=0, zerophase=false)\n\nHamming window of length n with padding zeros. The Hamming window does not reach zero at the endpoints and so has a shallower frequency roll-off when compared to the Hanning window, but is designed to cancel the first side-lobe.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.54 + 0.46*cos(2pi*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.tukey","page":"Windows - window functions","title":"DSP.Windows.tukey","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │            ▗▞▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄            │ \n  │           ▞▘                                             ▌           │ \n  │          ▗▘                                              ▝▌          │ \n  │         ▗▌                                                ▝▖         │ \n  │         ▞                                                  ▚         │ \n  │        ▗▘                                                  ▝▌        │ \n  │        ▞                                                    ▐        │ \n  │       ▐▘                                                     ▌       │ \n  │       ▌                                                      ▐▖      │ \n  │      ▐                                                        ▚      │ \n  │      ▌                                                        ▝▖     │ \n  │     ▞                                                          ▚     │ \n  │    ▞▘                                                           ▌    │ \n  │   ▗▘                                                            ▝▚   │ \n0 │ ▄▄▘                                                               ▚▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\ntukey(n::Integer, α::Real; padding::Integer=0, zerophase::Bool=false)\ntukey(dims, α; padding=0, zerophase=false)\n\nTukey window of length n with padding zeros. The Tukey window has a flat top and reaches zero at the endpoints, with a sinusoidal transition area parameterized by α. For α == 0, the window is equivalent to a rectangular window. For α == 1, the window is a Hann window.\n\nThe window is defined by sampling the continuous function:\n\n       ⎛              ⎛    ⎛    1 - α⎞⎞\n       ⎜      1 + cos ⎜2πα ⎜x + ─────⎟⎟             1 - α\n       ⎜              ⎝    ⎝      2  ⎠⎠         x ≤ ─────\n       ⎜      ─────────────────────────               2\n       ⎜                  2\n       ⎜\nw(x) = ⎜      1                                 -α/2 < x ≤ α/2\n       ⎜\n       ⎜              ⎛    ⎛    1 - α⎞⎞\n       ⎜      1 + cos ⎜2πα ⎜x - ─────⎟⎟             1 - α\n       ⎜              ⎝    ⎝      2  ⎠⎠         x > ─────\n       ⎜      ─────────────────────────               2\n       ⎝                  2\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. α, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.cosine","page":"Windows - window functions","title":"DSP.Windows.cosine","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                           ▗▄▞▀▀▀▀▀▀▀▀▀▀▀▄▄                           │ \n  │                        ▄▞▀▘               ▀▀▄▖                       │ \n  │                     ▗▞▀                      ▝▚▄                     │ \n  │                   ▄▀▘                           ▀▚▖                  │ \n  │                 ▄▀                                ▝▚▖                │ \n  │               ▄▀                                    ▝▚▖              │ \n  │             ▗▞                                        ▝▄             │ \n  │            ▞▘                                           ▀▖           │ \n  │          ▄▀                                              ▝▚▖         │ \n  │        ▗▞                                                  ▝▄        │ \n  │       ▄▘                                                     ▚▖      │ \n  │     ▗▞                                                        ▝▄     │ \n  │    ▄▘                                                           ▚▖   │ \n  │  ▗▞                                                              ▝▄  │ \n0 │ ▄▘                                                                 ▚▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\ncosine(n::Integer; padding::Integer=0, zerophase::Bool=false)\ncosine(dims; padding=0, zerophase=false)\n\nCosine window of length n with padding zeros. The cosine window is the first lobe of a cosine function (with the zero crossings at +/- π as endpoints). Also called the sine window.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = cos(πx)\n\nin the range [-0.5, 0.5]\n\nNote that the cosine window is the square root of the hanning window, so it is sometimes used when you are applying the window twice, such as the analysis and synthesis steps of an STFT.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.lanczos","page":"Windows - window functions","title":"DSP.Windows.lanczos","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                            ▗▄▞▀▀▀▀▀▀▀▀▀▄▄                            │ \n  │                         ▗▞▀▘             ▀▀▄                         │ \n  │                       ▄▀▘                   ▀▚                       │ \n  │                     ▄▀                        ▀▚▖                    │ \n  │                   ▄▀                            ▝▚▖                  │ \n  │                 ▗▀                                ▝▚                 │ \n  │               ▗▞▘                                   ▀▄               │ \n  │              ▞▘                                       ▀▖             │ \n  │            ▄▀                                          ▝▚▖           │ \n  │          ▗▞                                              ▝▄          │ \n  │         ▞▘                                                 ▀▖        │ \n  │       ▄▀                                                    ▝▚▖      │ \n  │     ▗▞                                                        ▝▄     │ \n  │   ▗▞▘                                                           ▀▄   │ \n0 │ ▄▞▘                                                               ▀▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nlanczos(n::Integer; padding::Integer=0, zerophase::Bool=false)\nlanczos(dims; padding=0, zerophase=false)\n\nLanczos window of length n with padding zeros. The Lanczos window is the main lobe of a sinc function.\n\nThe window is defined by sampling the continuous function:\n\n                  sin(2πx)\nw(x) = sinc(2x) = ────────\n                     2πx\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.triang","page":"Windows - window functions","title":"DSP.Windows.triang","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                                ▄▞▀▀▀▄▖                               │ \n  │                            ▗▄▞▀      ▝▀▄▖                            │ \n  │                         ▗▄▀▘            ▝▀▄▖                         │ \n  │                      ▗▄▀▘                  ▝▀▄▖                      │ \n  │                   ▗▄▀▘                        ▝▀▄▖                   │ \n  │                ▗▄▀▘                              ▝▀▄▄                │ \n  │             ▗▄▀▘                                     ▀▚▄             │ \n  │          ▗▄▀▘                                           ▀▙▄          │ \n  │       ▄▄▀▘                                                 ▀▚▄       │ \n  │    ▄▞▀                                                        ▀▚▄    │ \n  │ ▄▞▀                                                              ▀▚▄ │ \n  │▀                                                                    ▀│ \n  │                                                                      │ \n  │                                                                      │ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n  1                                                                      7\n\n\ntriang(n::Integer; padding::Integer=0, zerophase::Bool=false)\ntriang(dims; padding=0, zerophase=false)\n\nTriangular window of length n with padding zeros. The Triangular window does not reach zero at the endpoints. For odd n the triang window is the center n points of an n+2-point bartlett window (i.e. the samples just outside the window would be zero). For even n the window slope is the same as the n-1 window but delayed by a half sample so the zero points would be 1/2 sample past the ends of the window.\n\nThe window is defined by sampling the continuous function:\n\n        ⎛    2(n-1)\n        ⎜1 - ────── abs(x)     n is even\n        ⎜       n\nw(x) =  ⎜\n        ⎜    2(n-1)\n        ⎜1 - ────── abs(x)     n is odd\n        ⎝     n+1\n\nin the range [-0.5, 0.5].\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\nWhen zerophase is true substitute n+1 for n in the above window expressions.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.bartlett","page":"Windows - window functions","title":"DSP.Windows.bartlett","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                                 ▄▀▀▚▖                                │ \n  │                              ▗▄▀    ▝▚▄                              │ \n  │                            ▗▞▘         ▀▄                            │ \n  │                          ▄▞▘             ▀▄▖                         │ \n  │                        ▄▀                  ▝▚▖                       │ \n  │                     ▗▄▀                      ▝▄▄                     │ \n  │                   ▗▞▘                           ▀▄                   │ \n  │                 ▄▞▘                               ▀▄▖                │ \n  │               ▄▀                                    ▝▚▖              │ \n  │            ▗▞▀                                        ▝▀▄            │ \n  │          ▗▞▘                                             ▀▄          │ \n  │        ▄▀▘                                                 ▀▚▖       │ \n  │      ▄▀                                                      ▝▚▖     │ \n  │   ▗▞▀                                                          ▝▀▄   │ \n0 │ ▄▞▘                                                               ▀▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nbartlett(n::Integer; padding::Integer=0, zerophase::Bool=false)\nbartlett(dims; padding=0, zerophase=false)\n\nBartlett window of length n. The Bartlett window is a triangular window that reaches 0 at the endpoints. This is equivalent to convolving two rectangular windows of length (n-1)/2 and adding the zero endpoints. See triang for a window that does not reach zero at the endpoints.\n\nThe window is defined by sampling the continuous function:\n\n1 - abs(2x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.gaussian","page":"Windows - window functions","title":"DSP.Windows.gaussian","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                              ▄▞▀▀▀▀▀▀▀▄▖                             │ \n  │                            ▄▀          ▝▚▖                           │ \n  │                          ▄▀              ▝▚▖                         │ \n  │                        ▗▞                  ▝▄                        │ \n  │                       ▄▘                     ▚                       │ \n  │                     ▗▞                        ▚▄                     │ \n  │                    ▄▘                           ▚▖                   │ \n  │                  ▗▀                              ▝▚                  │ \n  │                 ▞▘                                 ▀▖                │ \n  │               ▄▀                                    ▝▚▖              │ \n  │             ▄▀                                        ▝▚▖            │ \n  │           ▄▀                                            ▝▚▖          │ \n  │        ▄▞▀                                                ▝▀▄▖       │ \n  │   ▗▄▄▀▀                                                      ▝▀▚▄▄   │ \n0 │ ▀▀▘                                                               ▀▀▘│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\ngaussian(n::Integer, σ::Real; padding::Integer=0, zerophase::Bool=false)\ngaussian(dims, σ; padding=0, zerophase=false)\n\nGives an n-sample gaussian window defined by sampling the function:\n\n        ⎛        2⎞\n        ⎜-1   ⎛x⎞ ⎟\n        ⎜── ⋅ ⎜─⎟ ⎟\n        ⎝ 2   ⎝σ⎠ ⎠\nw(x) = e\n\nin the range [-0.5,0.5]. This means that for σ=0.5 the endpoints of the window will correspond to 1 standard deviation away from the center.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. σ, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.bartlett_hann","page":"Windows - window functions","title":"DSP.Windows.bartlett_hann","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                              ▗▄▞▀▀▀▀▀▄▄                              │ \n  │                            ▄▀▘         ▀▚▖                           │ \n  │                          ▄▀              ▝▚▖                         │ \n  │                        ▄▀                  ▝▚▖                       │ \n  │                      ▗▀                      ▝▖                      │ \n  │                    ▗▞▘                        ▝▀▄                    │ \n  │                   ▄▘                             ▚▖                  │ \n  │                 ▗▞                                ▝▄                 │ \n  │                ▞▘                                   ▀▖               │ \n  │              ▄▀                                      ▝▚▖             │ \n  │            ▗▞                                          ▝▄            │ \n  │          ▗▞▘                                             ▀▄          │ \n  │        ▗▞▘                                                 ▀▄        │ \n  │      ▄▞▘                                                     ▀▄▖     │ \n0 │ ▄▄▄▀▀                                                          ▝▀▚▄▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nbartlett_hann(n::Integer; padding::Integer=0, zerophase::Bool=false)\nbartlett_hann(dims; padding=0, zerophase=false)\n\nBartlett-Hann window of length n with padding zeros. The Bartlett-Hann window is a weighted sum of the Bartlett and Hann windows.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.62 - 0.48*abs(x) + 0.38*cos(2π*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.blackman","page":"Windows - window functions","title":"DSP.Windows.blackman","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                               ▄▀▀▀▀▀▀▚▖                              │ \n  │                             ▄▀        ▝▚▖                            │ \n  │                           ▗▀            ▝▚                           │ \n  │                          ▞▘               ▀▖                         │ \n  │                        ▗▞                  ▝▄                        │ \n  │                       ▗▘                     ▚                       │ \n  │                      ▞▘                      ▝▚▖                     │ \n  │                     ▞                          ▝▖                    │ \n  │                   ▗▀                            ▝▚                   │ \n  │                  ▄▘                               ▚▖                 │ \n  │                ▗▞                                  ▝▄                │ \n  │               ▞▘                                     ▀▖              │ \n  │            ▗▄▀                                        ▝▚▄            │ \n  │         ▗▄▞▘                                             ▀▄▄         │ \n0 │ ▄▄▄▄▄▄▞▀▘                                                   ▀▀▄▄▄▄▄▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nblackman(n::Integer; padding::Integer=0, zerophase::Bool=false)\nblackman(dims; padding=0, zerophase=false)\n\nApproximates the \"Exact\" Blackman window. This is the generalized Blackman window with α = 0.16.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.42 + 0.5*cos(2π*x) + 0.08*cos(4π*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.kaiser","page":"Windows - window functions","title":"DSP.Windows.kaiser","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                               ▄▞▀▀▀▀▀▄▖                              │ \n  │                             ▄▀        ▝▚▖                            │ \n  │                           ▗▞            ▝▄                           │ \n  │                          ▗▘               ▚                          │ \n  │                         ▞▘                 ▀▖                        │ \n  │                        ▞                    ▝▖                       │ \n  │                      ▗▞                      ▐▖                      │ \n  │                     ▗▘                        ▝▚                     │ \n  │                    ▄▘                           ▚▖                   │ \n  │                   ▞                              ▝▖                  │ \n  │                 ▗▀                                ▝▚                 │ \n  │               ▗▞▘                                   ▀▄               │ \n  │             ▗▞▘                                       ▀▄             │ \n  │          ▗▄▞▘                                           ▀▄▄          │ \n0 │ ▄▄▄▄▄▄▄▞▀▘                                                 ▀▀▄▄▄▄▄▄▄▖│ \n  └──────────────────────────────────────────────────────────────────────┘ \n  0                                                                     70\n\n\nkaiser(n::Integer, α::Real; padding::Integer=0, zerophase::Bool=false)\nkaiser(dims, α; padding=0, zerophase=false)\n\nKaiser window of length n parameterized by α. The Kaiser window approximates the DPSS window (given by dpss), using a simplified definition relying on a Bessel function. Larger values for α give a wider main lobe but have lower sidelobes. Typically α is set around 3.\n\nThe window is defined by sampling the continuous function:\n\n         ⎛  ⎛   _________⎞⎞\n         ⎜  ⎜  ╱        2⎟⎟\nw(x) = I₀⎝πα⎝╲╱ 1 - (2x) ⎠⎠\n       ────────────────────\n               I₀(πα)\n\nin the range [-0.5, 0.5]\n\nWhere I₀(⋅) is the zeroth-order modified Bessel function of the first kind.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. α, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.dpss","page":"Windows - window functions","title":"DSP.Windows.dpss","text":"    ┌──────────────────────────────────────────────────────────────────────┐ \n0.2 │                              ▄▄▀▀▀▀▀▀▚▄▖                             │ \n    │                           ▗▞▀          ▝▀▄                           │ \n    │                         ▗▞▘               ▀▄                         │ \n    │                        ▄▘                   ▚▖                       │ \n    │                      ▗▀                      ▝▖                      │ \n    │                     ▞▘                        ▝▀▖                    │ \n    │                   ▄▀                            ▝▚▖                  │ \n    │                 ▗▞                                ▝▄                 │ \n    │                ▄▘                                   ▚▖               │ \n    │              ▗▞                                      ▝▄              │ \n    │            ▗▞▘                                         ▀▄            │ \n    │          ▗▞▘                                             ▀▄          │ \n    │        ▄▞▘                                                 ▀▄▖       │ \n    │     ▄▞▀                                                      ▝▀▄▖    │ \n  0 │ ▄▞▀▀                                                            ▝▀▀▄▖│ \n    └──────────────────────────────────────────────────────────────────────┘ \n    0                                                                     70\n\n\ndpss(n::Integer, nw::Real, ntapers::Integer=iceil(2*nw)-1;\n     padding::Integer=0, zerophase::Bool=false)\n\nThe first ntapers discrete prolate spheroid sequences (Slepian tapers) as an n × ntapers matrix. The signs of the tapers follow the convention that the first element of the skew-symmetric (odd) tapers is positive. The time-bandwidth product is given by nw.\n\nThe DPSS window maximizes the energy concentration in the main lobe.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.dpsseig","page":"Windows - window functions","title":"DSP.Windows.dpsseig","text":"dpsseig(A, nw)\n\nEigenvalues of the DPSS matrix, representing the ratios of the power within the main lobe to the total power (main and sidelobes). A is the output of dpss, and nw is the time-bandwidth product provided to dpss as input.\n\n\n\n\n\n","category":"function"},{"location":"contents/#Welcome-to-DSP.jl's-documentation!","page":"Contents","title":"Welcome to DSP.jl's documentation!","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"Contents:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"DSP.jl provides a number of common digital signal processing routines in Julia. So far, the following submodules are implemented:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Pages = [\"periodograms.md\",\n    \"estimation.md\",\n    \"windows.md\",\n    \"filters.md\",\n    \"util.md\",\n    \"convolutions.md\",\n    \"lpc.md\",\n    \"index.md\",\n]","category":"page"},{"location":"convolutions/#Convolutions-similarity-methods","page":"Convolutions - similarity methods","title":"Convolutions - similarity methods","text":"","category":"section"},{"location":"convolutions/","page":"Convolutions - similarity methods","title":"Convolutions - similarity methods","text":"conv\ndeconv\nxcorr","category":"page"},{"location":"convolutions/#DSP.conv","page":"Convolutions - similarity methods","title":"DSP.conv","text":"conv(u,v)\n\nConvolution of two arrays. Uses either FFT convolution or overlap-save, depending on the size of the input. u and v can be  N-dimensional arrays, with arbitrary indexing offsets, but their axes must be a UnitRange.\n\n\n\n\n\nconv(u,v,A)\n\n2-D convolution of the matrix A with the 2-D separable kernel generated by the vectors u and v. Uses 2-D FFT algorithm.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#DSP.deconv","page":"Convolutions - similarity methods","title":"DSP.deconv","text":"deconv(b,a) -> c\n\nConstruct vector c such that b = conv(a,c) + r. Equivalent to polynomial division.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#DSP.xcorr","page":"Convolutions - similarity methods","title":"DSP.xcorr","text":"xcorr(u,v; padmode = :none)\n\nCompute the cross-correlation of two vectors, by calculating the similarity between u and v with various offsets of v. Delaying u relative to v will shift the result to the right.\n\nThe size of the output depends on the padmode keyword argument: with padmode = :none the length of the result will be length(u) + length(v) - 1, as with conv. With padmode = :longest the shorter of the arguments will be padded so they are equal length. This gives a result with length 2*max(length(u), length(v))-1, with the zero-lag condition at the center.\n\n\n\n\n\n","category":"function"},{"location":"estimation/#Estimation-parametric-estimation-functions","page":"Estimation - parametric estimation functions","title":"Estimation - parametric estimation functions","text":"","category":"section"},{"location":"estimation/","page":"Estimation - parametric estimation functions","title":"Estimation - parametric estimation functions","text":"esprit","category":"page"},{"location":"estimation/#DSP.Estimation.esprit","page":"Estimation - parametric estimation functions","title":"DSP.Estimation.esprit","text":"esprit(x::AbstractArray, M::Integer, p::Integer, Fs::Real=1.0)\n\nESPRIT [Roy1986] algorithm for frequency estimation. Estimation of Signal Parameters via Rotational Invariance Techniques\n\nGiven length N signal \"x\" that is the sum of p sinusoids of unknown frequencies, estimate and return an array of the p frequencies.\n\nArguments\n\nx::AbstractArray: complex length N signal array\nM::Integer: size of correlation matrix, must be <= N.     The signal subspace is computed from the SVD of an M x (N-M+1) signal matrix     formed from N-M+1 length-M shifts of the signal x in its columns.     For best performance for 1 sinusoid, use M = (N+1)/3 (according to van der Veen and Leus).     For faster execution (due to smaller SVD), use small M or small N-M\np::Integer: number of sinusoids to estimate.\nFs::Float64: sampling frequency, in Hz.\n\nReturns\n\nlength p real array of frequencies in units of Hz.\n\n[Roy1986]: R Roy, A Paulraj and T Kailath, ESPRIT - A subspace approach to estimation of parameters of cisoids in noise, IEEE Trans. Acoustics, Speech, Signal Process., 34, 1340-1342 (1986). url.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filters-filter-design-and-filtering","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl differentiates between filter coefficients and stateful filters. Filter coefficient objects specify the response of the filter in one of several standard forms. Stateful filter objects carry the state of the filter together with filter coefficients in an implementable form (PolynomialRatio, Biquad, or SecondOrderSections). When invoked on a filter coefficient object, filt does not preserve state.","category":"page"},{"location":"filters/#coefficient-objects","page":"Filters - filter design and filtering","title":"Filter coefficient objects","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl supports common filter representations. Filter coefficients can be converted from one type to another using convert.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"ZeroPoleGain\nPolynomialRatio\nBiquad\nSecondOrderSections","category":"page"},{"location":"filters/#DSP.Filters.ZeroPoleGain","page":"Filters - filter design and filtering","title":"DSP.Filters.ZeroPoleGain","text":"ZeroPoleGain(z, p, k)\n\nFilter representation in terms of zeros z, poles p, and gain k:\n\nH(x) = kfrac(x - verbz1) ldots (x - verbzm)(x - verbp1) ldots (x - verbpn)\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.PolynomialRatio","page":"Filters - filter design and filtering","title":"DSP.Filters.PolynomialRatio","text":"PolynomialRatio(b, a)\n\nFilter representation in terms of the coefficients of the numerator b and denominator a of the transfer function:\n\nH(s) = fracverbb1 s^m-1 + ldots + verbbmverba1 s^n-1 + ldots + verban\n\nor equivalently:\n\nH(z) = fracverbb1 + ldots + verbbn z^-n+1verba1 + ldots + verban z^-n+1\n\nb and a may be specified as Polynomial objects or vectors ordered from highest power to lowest.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Biquad","page":"Filters - filter design and filtering","title":"DSP.Filters.Biquad","text":"Biquad(b0, b1, b2, a1, a2)\n\nFilter representation in terms of the transfer function of a single second-order section given by:\n\nH(s) = fracverbb0 s^2+verbb1 s+verbb2s^2+verba1 s + verba2\n\nor equivalently:\n\nH(z) = fracverbb0+verbb1 z^-1+verbb2 z^-21+verba1 z^-1 + verba2 z^-2\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.SecondOrderSections","page":"Filters - filter design and filtering","title":"DSP.Filters.SecondOrderSections","text":"SecondOrderSections(biquads, gain)\n\nFilter representation in terms of a cascade of second-order sections and gain. biquads must be specified as a vector of Biquads.\n\n\n\n\n\n","category":"type"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"These filter coefficient objects support the following arithmetic operations: inversion (inv), multiplication (*) for series connection, and integral power (^) for repeated mutlpilcation with itself. For example:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"julia> H = PolynomialRatio([1.0], [1.0, 0.3])\nPolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.3*z⁻¹ + 1.0))\n\njulia> inv(H)\nPolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(0.3*z⁻¹ + 1.0), Polynomials.LaurentPolynomial(1.0))\n\njulia> H * H\nPolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))\n\njulia> H^2\nPolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))\n\njulia> H^-2\nPolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0), Polynomials.LaurentPolynomial(1.0))\n","category":"page"},{"location":"filters/#stateful-filter-objects","page":"Filters - filter design and filtering","title":"Stateful filter objects","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DF2TFilter","category":"page"},{"location":"filters/#DSP.Filters.DF2TFilter","page":"Filters - filter design and filtering","title":"DSP.Filters.DF2TFilter","text":"DF2TFilter(coef[, si])\n\nConstruct a stateful direct form II transposed filter with coefficients coef. si is an optional array representing the initial filter state (defaults to zeros). If f is a PolynomialRatio, Biquad, or SecondOrderSections, filtering is implemented directly. If f is a ZeroPoleGain object, it is first converted to a SecondOrderSections object.\n\n\n\n\n\n","category":"type"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl's FIRFilter type maintains state between calls to filt, allowing you to filter a signal of indefinite length in RAM-friendly chunks. FIRFilter contains nothing more that the state of the filter, and a FIRKernel. There are five different kinds of FIRKernel for single rate, up-sampling, down-sampling, rational resampling, and arbitrary sample-rate conversion. You need not specify the type of kernel. The FIRFilter constructor selects the correct kernel based on input parameters.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"FIRFilter","category":"page"},{"location":"filters/#DSP.Filters.FIRFilter","page":"Filters - filter design and filtering","title":"DSP.Filters.FIRFilter","text":"FIRFilter(h[, ratio])\n\nConstruct a stateful FIRFilter object from the vector of filter taps h. ratio is an optional rational integer which specifies the input to output sample rate relationship (e.g. 147//160 for converting recorded audio from 48 KHz to 44.1 KHz).\n\n\n\n\n\nFIRFilter(h, rate[, Nϕ])\n\nReturns a polyphase FIRFilter object from the vector of filter taps h. rate is a floating point number that specifies the input to output sample-rate relationship fracfs_outfs_in. Nϕ is an optional parameter which specifies the number of phases created from h. Nϕ defaults to 32.\n\n\n\n\n\n","category":"type"},{"location":"filters/#Filter-application","page":"Filters - filter design and filtering","title":"Filter application","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"filt\nfilt!\nfiltfilt\nfftfilt\nfftfilt!\ntdfilt\ntdfilt!\nresample","category":"page"},{"location":"filters/#DSP.filt","page":"Filters - filter design and filtering","title":"DSP.filt","text":"filt(b, a, x, [si])\n\nApply filter described by vectors a and b to vector x, with an optional initial filter state vector si (defaults to zeros).\n\n\n\n\n\nfilt(f, x[, si])\n\nApply filter or filter coefficients f along the first dimension of array x. If f is a filter coefficient object, si is an optional array representing the initial filter state (defaults to zeros). If f is a PolynomialRatio, Biquad, or SecondOrderSections, filtering is implemented directly. If f is a ZeroPoleGain object, it is first converted to a SecondOrderSections object.  If f is a Vector, it is interpreted as an FIR filter, and a naïve or FFT-based algorithm is selected based on the data and filter length.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.filt!","page":"Filters - filter design and filtering","title":"DSP.filt!","text":"filt!(out, b, a, x, [si])\n\nSame as filt but writes the result into the out argument, which may alias the input x to modify it in-place.\n\n\n\n\n\nfilt!(out, f, x[, si])\n\nSame as filt() but writes the result into the out argument. Output array out may not be an alias of x, i.e. filtering may not be done in place.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.filtfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.filtfilt","text":"filtfilt(coef, x)\n\nFilter x in the forward and reverse directions using filter coefficients coef. The initial state of the filter is computed so that its response to a step function is steady state. Before filtering, the data is extrapolated at both ends with an odd-symmetric extension of length 3*(max(length(b), length(a))-1).\n\nBecause filtfilt applies the given filter twice, the effective filter order is twice the order of coef. The resulting signal has zero phase distortion.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.fftfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.fftfilt","text":"fftfilt(h, x)\n\nApply FIR filter taps h along the first dimension of array x using an FFT-based overlap-save algorithm.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.fftfilt!","page":"Filters - filter design and filtering","title":"DSP.Filters.fftfilt!","text":"fftfilt!(out, h, x)\n\nLike fftfilt but writes result into out array.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.tdfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.tdfilt","text":"tdfilt(h, x)\n\nApply filter or filter coefficients h along the first dimension of array x using a naïve time-domain algorithm\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.tdfilt!","page":"Filters - filter design and filtering","title":"DSP.Filters.tdfilt!","text":"tdfilt!(out, h, x)\n\nLike tdfilt, but writes the result into array out. Output array out may not be an alias of x, i.e. filtering may not be done in place.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.resample","page":"Filters - filter design and filtering","title":"DSP.Filters.resample","text":"resample(x, rate[, coef])\n\nResample x at rational or arbitrary rate. coef is an optional vector of FIR filter taps. If coef is not provided, the taps will be computed using a Kaiser window.\n\nInternally, resample uses a polyphase FIRFilter object, but performs additional operations to make resampling a signal easier. It compensates for the FIRFilter's delay (ramp-up), and appends zeros to x. The result is that when the input and output signals are plotted on top of each other, they correlate very well, but one signal will have more samples that the other.\n\n\n\n\n\nresample(x::AbstractMatrix, rate::Real, h::Vector = resample_filter(rate); dims)\n\nResample a matrix x along dimension dims.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filter-design","page":"Filters - filter design and filtering","title":"Filter design","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Most analog and digital filters are constructed by composing response types, which determine the frequency response of the filter, with design methods, which determine how the filter is constructed. The response type is Lowpass, Highpass, Bandpass or Bandstop and includes the edges of the bands. The design method is Butterworth, Chebyshev1, Chebyshev2,  Elliptic, or FIRWindow, and includes any necessary parameters for the method that affect the shape of the response, such as filter order, ripple, and attenuation.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"analogfilter\ndigitalfilter","category":"page"},{"location":"filters/#DSP.Filters.analogfilter","page":"Filters - filter design and filtering","title":"DSP.Filters.analogfilter","text":"analogfilter(responsetype, designmethod)\n\nConstruct an analog filter. See below for possible response and filter types.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.digitalfilter","page":"Filters - filter design and filtering","title":"DSP.Filters.digitalfilter","text":"digitalfilter(responsetype, designmethod)\n\nConstruct a digital filter. See below for possible response and filter types.\n\n\n\n\n\n","category":"function"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"For some filters, the design method is more general or  inherently implies a response type; these direct design methods include remez which designs equiripple FIR filters of all types, and iirnotch which designs a  2nd order \"biquad\" IIR notch filter.","category":"page"},{"location":"filters/#response-types","page":"Filters - filter design and filtering","title":"Filter response types","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Lowpass\nHighpass\nBandpass\nBandstop","category":"page"},{"location":"filters/#DSP.Filters.Lowpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Lowpass","text":"Lowpass(Wn[; fs])\n\nLow pass filter with cutoff frequency Wn. If fs is not specified, Wn is interpreted as a normalized frequency in half-cycles/sample.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Highpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Highpass","text":"Highpass(Wn[; fs])\n\nHigh pass filter with cutoff frequency Wn. If fs is not specified, Wn is interpreted as a normalized frequency in half-cycles/sample.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Bandpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Bandpass","text":"Bandpass(Wn1, Wn2[; fs])\n\nBand pass filter with normalized pass band (Wn1, Wn2). If fs is not specified, Wn1 and Wn2 are interpreted as normalized frequencies in half-cycles/sample.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Bandstop","page":"Filters - filter design and filtering","title":"DSP.Filters.Bandstop","text":"Bandstop(Wn1, Wn2[; fs])\n\nBand stop filter with normalized stop band (Wn1, Wn2). If fs is not specified, Wn1 and Wn2 are interpreted as normalized frequencies in half-cycles/sample.\n\n\n\n\n\n","category":"type"},{"location":"filters/#design-methods","page":"Filters - filter design and filtering","title":"Filter design methods","text":"","category":"section"},{"location":"filters/#IIR-filter-design-methods","page":"Filters - filter design and filtering","title":"IIR filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Butterworth\nChebyshev1\nChebyshev2\nElliptic","category":"page"},{"location":"filters/#DSP.Filters.Butterworth","page":"Filters - filter design and filtering","title":"DSP.Filters.Butterworth","text":"Butterworth(n)\n\nn pole Butterworth filter.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Chebyshev1","page":"Filters - filter design and filtering","title":"DSP.Filters.Chebyshev1","text":"Chebyshev1(n, ripple)\n\nn pole Chebyshev type I filter with ripple dB ripple in the passband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Chebyshev2","page":"Filters - filter design and filtering","title":"DSP.Filters.Chebyshev2","text":"Chebyshev2(n, ripple)\n\nn pole Chebyshev type II filter with ripple dB ripple in the stopband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Elliptic","page":"Filters - filter design and filtering","title":"DSP.Filters.Elliptic","text":"Elliptic(n, rp, rs)\n\nn pole elliptic (Cauer) filter with rp dB ripple in the passband and rs dB attentuation in the stopband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#FIR-filter-design-methods","page":"Filters - filter design and filtering","title":"FIR filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"FIRWindow","category":"page"},{"location":"filters/#DSP.Filters.FIRWindow","page":"Filters - filter design and filtering","title":"DSP.Filters.FIRWindow","text":"FIRWindow(window; scale=true)\n\nFIR filter design using window window, a vector whose length matches the number of taps in the resulting filter.\n\nIf scale is true (default), the designed FIR filter is scaled so that the following holds:\n\nFor Lowpass and Bandstop filters, the frequency response is unity at 0 (DC).\nFor Highpass filters, the frequency response is unity at the Nyquist frequency.\nFor Bandpass filters, the frequency response is unity in the center of the passband.\n\n\n\n\n\nFIRWindow(; transitionwidth, attenuation=60, scale=true)\n\nKaiser window FIR filter design. The required number of taps is calculated based on transitionwidth (in half-cycles/sample) and stopband attenuation (in dB). attenuation defaults to 60 dB.\n\n\n\n\n\n","category":"type"},{"location":"filters/#direct-design-methods","page":"Filters - filter design and filtering","title":"Direct filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"remez\niirnotch","category":"page"},{"location":"filters/#DSP.Filters.remez","page":"Filters - filter design and filtering","title":"DSP.Filters.remez","text":"remez(numtaps::Integer, band_defs;\n      Hz::Real=1.0,\n      neg::Bool=false,\n      maxiter::Integer=25,\n      grid_density::Integer=16)\n\nCalculate the minimax optimal filter using the Remez exchange algorithm [McClellan1973a] [McClellan1973b].\n\nThis is the simplified API that accepts just 2 required arguments (numtaps, band_defs). For a scipy compatible version see the 3 arguments version (numtaps, bands, desired). \n\nCalculate the filter-coefficients for the finite impulse response (FIR) filter whose transfer function minimizes the maximum error between the desired gain and the realized gain in the specified frequency bands using the Remez exchange algorithm.\n\nArguments\n\nnumtaps::Integer: The desired number of taps in the filter.    The number of taps is the number of terms in the filter, or the filter    order plus one.\nbands_defs: A sequence of band definitions.   This sequence defines the bands. Each entry is a pair. The pair's   first item is a tuple of band edges (low, high). The pair's second item    defines the desired response and weight in that band. The weight is optional   and defaults to 1.0. Both the desired response and weight may be either scalars   or functions. If a function, the function should accept a real frequency and   return the real desired response or real weight. Examples:\nLPF with unity weights. [(0, 0.475) => 1, (0.5, 1.0) => 0]\nLPF with weight of 2 in the stop band. [(0, 0.475) => (1, 1), (0.5, 1.0) => (0, 2)]\nBPF with unity weights. [(0, 0.375) => 0, (0.4, 0.5) => 1, (0.525, 1.0) => 0]\nHilbert transformer. [(0.1, 0.95) => 1]; neg=true\nDifferentiator. [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true\nHz::Real: The sampling frequency in Hz. Default is 1.\nneg::Bool: Whether the filter has negative symmetry or not. Default is false.   If false, the filter is even-symmetric. If true, the filter is odd-symmetric.   neg=true means that h[n]=-h[end+1-n]; neg=false means that h[n]=h[end+1-n].\nmaxiter::Integer: (optional)   Maximum number of iterations of the algorithm. Default is 25.\ngrid_density:Integer: (optional)   Grid density. The dense grid used in remez is of size   (numtaps + 1) * grid_density. Default is 16.\n\nReturns\n\nh::Array{Float64,1}: A rank-1 array containing the coefficients of the optimal   (in a minimax sense) filter.\n\n[McClellan1973a]: \n\nJ. H. McClellan and T. W. Parks, A unified approach to the design of optimum FIR linear phase digital filters, IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.\n\n[McClellan1973b]: \n\nJ. H. McClellan, T. W. Parks and L. R. Rabiner, A Computer Program for Designing Optimum FIR Linear Phase Digital Filters, IEEE Trans. Audio Electroacoust., vol. AU-21, pp. 506-525, 1973.\n\nExamples\n\nConstruct a length 35 filter with a passband at 0.15-0.4 Hz  (desired response of 1), and stop bands at 0-0.1 Hz and 0.45-0.5 Hz (desired response of 0). Note: the behavior in the frequency ranges between  those bands - the transition bands - is unspecified.\n\njulia> bpass = remez(35, [(0, 0.1)=>0, (0.15, 0.4)=>1, (0.45, 0.5)=>0]);\n\nYou can trade-off maximum error achieved for transition bandwidth.  The wider the transition bands, the lower the maximum error in the bands specified. Here is a bandpass filter with the same passband, but wider transition bands.\n\njulia> bpass2 = remez(35, [(0, 0.08)=>0, (0.15, 0.4)=>1, (0.47, 0.5)=>0]);\n\nHere we compute the frequency responses and plot them in dB.\n\njulia> using PyPlot\njulia> b = DSP.Filters.PolynomialRatio(bpass, [1.0])\njulia> b2 = DSP.Filters.PolynomialRatio(bpass2, [1.0])\njulia> f = range(0, stop=0.5, length=1000)\njulia> plot(f, 20*log10.(abs.(freqresp(b,f,1.0))))\njulia> plot(f, 20*log10.(abs.(freqresp(b2,f,1.0))))\njulia> grid()\n\nExamples from the unittests - standard (even) symmetry.\n\nLength 151 LPF (Low Pass Filter).\n\njulia> h = remez(151, [(0, 0.475) => 1, (0.5, 1.0) => 0]; Hz=2.0);\n\nLength 152 LPF. Non-default \"weight\" input.\n\njulia> h = remez(152, [(0, 0.475) => (1, 1), (0.5, 1.0) => (0, 2)]; Hz=2.0);\n\nLength 51 HPF (High Pass Filter).\n\njulia> h = remez(51, [(0, 0.75) => 0, (0.8, 1.0) => 1]; Hz=2.0);\n\nLength 180 BPF (Band Pass Filter).\n\njulia> h = remez(180, [(0, 0.375) => 0, (0.4, 0.5) => 1, (0.525, 1.0) => 0]; Hz=2.0, maxiter=30);\n\nExamples from the unittests - Odd-symmetric filters - hilbert and differentiators type.\n\nEven length - has a much better approximation since the response is not constrained to 0 at the nyquist frequency.  Length 20 Hilbert transformer.\n\njulia> h = remez(20, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\nLength 21 Hilbert transformer.\n\njulia> h = remez(21, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\nLength 200 differentiator.\n\njulia> h = remez(200, [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\nLength 201 differentiator.\n\njulia> h = remez(201, [(0.05, 0.95) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\nInverse sinc filter - custom response function\n\njulia> L = 64; Fs = 4800*L;\njulia> passband_response_function = f -> (f==0) ? 1.0 : abs.((π*f/4800) ./ sin.(π*f/4800));\njulia> h = remez(201, [(    0.0, 2880.0) => (passband_response_function, 1.0),\n                (10000.0,   Fs/2) => (0.0, 100.0)]; Hz=Fs);\n\n\n\n\n\nremez(numtaps::Integer, \n      bands::Vector, \n      desired::Vector; \n      weight::Vector=[], \n      Hz::Real=1.0, \n      filter_type::RemezFilterType=filter_type_bandpass,\n      maxiter::Integer=25, \n      grid_density::Integer=16)\n\nThis is the scipy compatible version that requires 3 arguments (numtaps, bands, desired).  For a simplified API, see the 2 argument version (numtaps, band_defs). The filters designed are equivalent, the inputs are just specified in a different way. Below the arguments and examples are described that differ from the simplified API version.\n\nArguments\n\nbands::Vector: A monotonic sequence containing the band edges in Hz.   All elements must be non-negative and less than half the sampling   frequency as given by Hz.\ndesired::Vector:A sequence half the size of bands containing the desired    gain in each of the specified bands.\nweight::Vector: (optional)   A relative weighting to give to each band region. The length of   weight has to be half the length of bands.\nfilter_type::RemezFilterType: Default is filter_type_bandpass.   The type of filter:\nfilter_type_bandpass : flat response in bands. This is the default.\nfilter_type_differentiator : frequency proportional response in bands.   Odd symetric as in filter_type_hilbert case, but with a linear sloping   desired response.\nfilter_type_hilbert : filter with odd symmetry, that is, type III             (for even order) or type IV (for odd order)             linear phase filters.\n\nExamples\n\nCompare the examples with the simplified API and the Scipy API. Each of the following blocks first designs a filter using the  simplified (recommended) API, and then designs the same filter using the Scipy-compatible API.\n\njulia> bpass = remez(35, [(0, 0.1)=>0, (0.15, 0.4)=>1, (0.45, 0.5)=>0]);\n\njulia> bpass = remez(35, [0, 0.1, 0.15, 0.4, 0.45, 0.5], [0, 1, 0]);\n\n\njulia> bpass2 = remez(35, [(0, 0.08)=>0, (0.15, 0.4)=>1, (0.47, 0.5)=>0]);\n\njulia> bpass2 = remez(35, [0, 0.08, 0.15, 0.4, 0.47, 0.5], [0, 1, 0]);\n\n\njulia> h = remez(20, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\njulia> h = remez(20, [0.1, 0.95], [1]; filter_type=filter_type_hilbert, Hz=2.0);\n\n\njulia> h = remez(200, [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\njulia> h = remez(200, [0.01, 0.99], [1]; filter_type=filter_type_differentiator, Hz=2.0);\n\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.iirnotch","page":"Filters - filter design and filtering","title":"DSP.Filters.iirnotch","text":"iirnotch(Wn, bandwidth[; fs])\n\nSecond-order digital IIR notch filter [Orfandis] at frequency Wn with bandwidth bandwidth. If fs is not specified, Wn is interpreted as a normalized frequency in half-cycles/sample.\n\n[Orfandis]: Orfanidis, S. J. (1996). Introduction to signal processing. Englewood Cliffs, N.J: Prentice Hall, p. 370.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filter-response","page":"Filters - filter design and filtering","title":"Filter response","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"freqresp\nphaseresp\ngrpdelay\nimpresp\nstepresp","category":"page"},{"location":"filters/#DSP.Filters.freqresp","page":"Filters - filter design and filtering","title":"DSP.Filters.freqresp","text":"H, w = freqresp(filter)\n\nFrequency response H of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\nfreqresp(filter::FilterCoefficients{:z}, w)\n\nFrequency response of digital filter at normalized frequency or frequencies w in radians/sample.\n\n\n\n\n\nfreqresp(filter::FilterCoefficients{:s}, w)\n\nFrequency response of analog filter at frequency or frequencies w in radians/second.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.phaseresp","page":"Filters - filter design and filtering","title":"DSP.Filters.phaseresp","text":"phi, w = phaseresp(filter)\n\nPhase response phi of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\nphaseresp(filter, w)\n\nPhase response of a filter at (normalized) frequency or frequencies w in radians/sample for a digital filter or radians/second for an analog filter.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.grpdelay","page":"Filters - filter design and filtering","title":"DSP.Filters.grpdelay","text":"tau, w = grpdelay(filter)\n\nGroup delay tau of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\ngrpdelay(fliter, w)\n\nGroup delay of a digital 'filter' at normalized frequency or frequencies 'w' in radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.impresp","page":"Filters - filter design and filtering","title":"DSP.Filters.impresp","text":"impresp(filter, n=100)\n\nImpulse response of a digital filter with n points.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.stepresp","page":"Filters - filter design and filtering","title":"DSP.Filters.stepresp","text":"stepresp(filter, n=100)\n\nStep response of a digital filter with n points.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Miscellaneous","page":"Filters - filter design and filtering","title":"Miscellaneous","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"coefb\ncoefa","category":"page"},{"location":"filters/#DSP.Filters.coefb","page":"Filters - filter design and filtering","title":"DSP.Filters.coefb","text":"coefb(f)\n\nCoefficients of the numerator of a PolynomialRatio object, highest power first, i.e., the b passed to filt()\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.coefa","page":"Filters - filter design and filtering","title":"DSP.Filters.coefa","text":"coefa(f)\n\nCoefficients of the denominator of a PolynomialRatio object, highest power first, i.e., the a passed to filt()\n\n\n\n\n\n","category":"function"},{"location":"filters/#Examples","page":"Filters - filter design and filtering","title":"Examples","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Construct a 4th order elliptic lowpass filter with normalized cutoff frequency 0.2, 0.5 dB of passband ripple, and 30 dB attentuation in the stopband and extract the coefficients of the numerator and denominator of the transfer function:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Lowpass(0.2)\ndesignmethod = Elliptic(4, 0.5, 30)\ntf = convert(PolynomialRatio, digitalfilter(responsetype, designmethod))\nnumerator_coefs = coefb(tf)\ndenominator_coefs = coefa(tf)","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Filter the data in x, sampled at 1000 Hz, with a 4th order Butterworth bandpass filter between 10 and 40 Hz:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Bandpass(10, 40; fs=1000)\ndesignmethod = Butterworth(4)\nfilt(digitalfilter(responsetype, designmethod), x)","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Filter the data in x, sampled at 50 Hz, with a 64 tap Hanning window FIR lowpass filter at 5 Hz:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Lowpass(5; fs=50)\ndesignmethod = FIRWindow(hanning(64))\nfilt(digitalfilter(responsetype, designmethod), x)","category":"page"},{"location":"lpc/#LPC-Linear-Predictive-Coding","page":"LPC - Linear Predictive Coding","title":"LPC - Linear Predictive Coding","text":"","category":"section"},{"location":"lpc/","page":"LPC - Linear Predictive Coding","title":"LPC - Linear Predictive Coding","text":"lpc\nlpc(::AbstractVector{Number}, ::Int, ::LPCBurg)\nlpc(::AbstractVector{Number}, ::Int, ::LPCLevinson)","category":"page"},{"location":"lpc/#DSP.LPC.lpc","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.lpc","text":"lpc(x::AbstractVector, p::Int, [LPCBurg()])\n\nGiven input signal x and prediction order p, returns IIR coefficients a and average reconstruction error prediction_err. Note that this method does NOT return the leading 1 present in the true autocorrelative estimate; it omits it as it is implicit in every LPC estimate, and must be manually reintroduced if the returned vector should be treated as a polynomial.\n\nThe algorithm used is determined by the last optional parameter, and can be either LPCBurg or LPCLevinson.\n\n\n\n\n\n","category":"function"},{"location":"lpc/#DSP.LPC.lpc-Tuple{AbstractVector{Number}, Int64, LPCBurg}","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.lpc","text":"lpc(x::AbstractVector, p::Int, LPCBurg())\n\nLPC (Linear-Predictive-Code) estimation, using the Burg method. This function implements the mathematics published in [1].\n\n[1] - Enhanced Partial Tracking Using Linear Prediction (DAFX 2003 article, Lagrange et al) http://www.sylvain-marchand.info/Publications/dafx03.pdf\n\n\n\n\n\n","category":"method"},{"location":"lpc/#DSP.LPC.lpc-Tuple{AbstractVector{Number}, Int64, LPCLevinson}","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.lpc","text":"lpc(x::AbstractVector, p::Int, LPCLevinson())\n\nLPC (Linear-Predictive-Code) estimation, using the Levinson method. This function implements the mathematics described in [1].\n\n[1] - The Wiener (RMS) Error Criterion in Filter Design and Prediction (N. Levinson, Studies in Applied Mathematics 25(1946), 261-278, https://doi.org/10.1002/sapm1946251261)\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"periodograms/#Periodograms-periodogram-estimation","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"arraysplit\nperiodogram(s::AbstractVector{T}) where T <: Number\nwelch_pgram\nspectrogram\nstft\nperiodogram(s::AbstractMatrix{T}) where T <: Real\nfreq\npower\ntime\ncoherence","category":"page"},{"location":"periodograms/#DSP.Periodograms.arraysplit","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.arraysplit","text":"arraysplit(s, n, m)\n\nSplit an array into arrays of length n with overlapping regions of length m. Iterating or indexing the returned AbstractVector always yields the same Vector with different contents.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.periodogram-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Number","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.periodogram","text":"periodogram(s; onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes periodogram of a signal by FFT and returns a Periodogram object.\n\nFor real signals, the two-sided periodogram is symmetric and this function returns a one-sided (real only) periodogram by default. A two-sided periodogram can be obtained by setting onesided=false.\n\nnfft specifies the number of points to use for the Fourier transform. If length(s) < nfft, then the input is padded with zeros. By default, nfft is the closest size for which the Fourier transform can be computed with maximal efficiency.\n\nfs is the sample rate of the original signal, and window is an optional window function or vector to be applied to the original signal before computing the Fourier transform. The computed periodogram is normalized so that the area under the periodogram is equal to the uncentered variance (or average power) of the original signal.\n\n\n\n\n\n","category":"method"},{"location":"periodograms/#DSP.Periodograms.welch_pgram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.welch_pgram","text":"welch_pgram(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the Welch periodogram of a signal s based on segments with n samples with overlap of noverlap samples, and returns a Periodogram object. For a Bartlett periodogram, set noverlap=0. See periodogram for description of optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.spectrogram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.spectrogram","text":"spectrogram(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the spectrogram of a signal s based on segments with n samples with overlap of noverlap samples, and returns a Spectrogram object. See periodogram for description of optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.stft","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.stft","text":"stft(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the STFT of a signal s based on segments with n samples with overlap of noverlap samples, and returns a matrix containing the STFT coefficients. See periodogram for description of optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.periodogram-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.periodogram","text":"periodogram(s::AbstractMatrix; nfft=nextfastfft(size(s)), fs=1, radialsum=false, radialavg=false)\n\nComputes periodogram of a 2-d signal by FFT and returns a Periodogram2 object.\n\nReturns a 2-d periodogram by default. A radially summed or averaged periodogram is returned as a Periodogram object if radialsum or  radialavg is true, respectively.\n\nnfft specifies the number of points to use for the Fourier transform. If size(s) < nfft, then the input is padded with zeros. By default, nfft is the closest size for which the Fourier transform can be computed with maximal efficiency. fs is the sample rate of the original signal in both directions.\n\nFor radialsum=true the value of power[k] is proportional to frac1Nsum_kleq kk+1 Xk^2. For radialavg=true it is proportional to frac1N kleq kk+1 sum_kleq kk+1 Xk^2. The computation of |k'| takes into account non-square signals by scaling the coordinates of the wavevector accordingly.\n\n\n\n\n\n","category":"method"},{"location":"periodograms/#DSP.Periodograms.freq","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.freq","text":"freq(p)\n\nReturns the frequency bin centers for a given Periodogram, Spectrogram, CrossPowerSpectra, or Coherence object.\n\nReturns a tuple of frequency bin centers for a given Periodogram2 object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.power","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.power","text":"power(p)\n\nFor a Periodogram, returns the computed power at each frequency as a Vector.\n\nFor a Spectrogram, returns the computed power at each frequency and time bin as a Matrix. Dimensions are frequency × time.\n\nFor a CrossPowerSpectra, returns the pairwise power between each pair of channels at each frequency. Dimensions are channel x channel x frequency.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Base.Libc.time","page":"Periodograms - periodogram estimation","title":"Base.Libc.time","text":"time(p)\n\nReturns the time bin centers for a given Spectrogram object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.coherence","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.coherence","text":"coherence(c::Coherence)\n\nGiven an Coherence object, returns an n_channels x n_channels x length(freq(c)) array consisting of the pairwise coherences between each channel for each frequency.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Multitaper-periodogram-estimation","page":"Periodograms - periodogram estimation","title":"Multitaper periodogram estimation","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"mt_pgram\nmt_pgram!\nmt_spectrogram\nmt_spectrogram!\nmt_cross_power_spectra\nmt_cross_power_spectra!\nmt_coherence\nmt_coherence!","category":"page"},{"location":"periodograms/#DSP.Periodograms.mt_pgram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_pgram","text":"mt_pgram(s; onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, nw=4, ntapers=iceil(2nw)-1, window=dpss(length(s), nw, ntapers))\nmt_pgram(signal::AbstractVector, config::MTConfig)\n\nComputes the multitaper periodogram of a signal s.\n\nIf window is not specified, the signal is tapered with ntapers discrete prolate spheroidal sequences with time-bandwidth product nw. Each sequence is equally weighted; adaptive multitaper is not (yet) supported.\n\nIf window is specified, each column is applied as a taper. The sum of periodograms is normalized by the total sum of squares of window.\n\nReturns a Periodogram.\n\nSee also mt_pgram! and MTConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_pgram!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_pgram!","text":"mt_pgram!(output, s::AbstractVector{T}; onesided::Bool=eltype(s)<:Real,\n    nfft::Int=nextfastfft(length(s)), fs::Real=1,\n    nw::Real=4, ntapers::Int=ceil(Int, 2nw)-1,\n    window::Union{AbstractMatrix,Nothing}=nothing) where T<:Number\nmt_pgram!(output::AbstractVector, signal::AbstractVector, config::MTConfig) -> Periodogram\n\nComputes a multitapered periodogram, storing the output in output. Arguments:\n\nsignal::AbstractVector: should be of length config.n_samples\noutput::AbstractVector: should be of length length(config.freq)\n\nOptionally pass an MTConfig object to preallocate temporary variables and choose configuration settings; otherwise, keyword arguments may be passed to choose those settings.\n\nReturns a Periodogram.\n\nSee also mt_pgram and MTConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_spectrogram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_spectrogram","text":"mt_spectrogram(signal::AbstractVector{T}, n::Int=length(s) >> 3,\n                              n_overlap::Int=n >> 1; fs::Int=1,\n                              onesided::Bool=T <: Real, kwargs...) where {T}\nmt_spectrogram(signal::AbstractVector, config::MTSpectrogramConfig)\n\nCompute a multitaper spectrogram, returning a Spectrogram object. Optionally pass a MTSpectrogramConfig object; otherwise, any additional keyword arguments accepted by MTConfig may be passed to configure the tapering.\n\nReturns a Spectrogram.\n\nSee also mt_spectrogram!.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_spectrogram!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_spectrogram!","text":"mt_spectrogram!(output, signal::AbstractVector{T}, n::Int=length(signal) >> 3,\n    n_overlap::Int=n >> 1; fs::Int=1, onesided::Bool=T <: Real, kwargs...) where {T}\nmt_spectrogram!(destination::AbstractMatrix, signal::AbstractVector, config::MTSpectrogramConfig)\n\nComputes a multitaper spectrogram using the parameters specified in config. Arguments:\n\ndestination: length(config.mt_config.freq) x length(config.time) matrix. This can be created by DSP.allocate_output(config).\nsignal: vector of length config.n_samples\nconfig: optionally, pass an MTSpectrogramConfig object to hold temporary variables and configuration settings. Otherwise, settings arguments may be passed directly.\n\nReturns a Spectrogram.\n\nSee also mt_spectrogram.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_cross_power_spectra","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_cross_power_spectra","text":"mt_cross_power_spectra(signal::AbstractMatrix{T}; fs=1, kwargs...) where {T}\nmt_cross_power_spectra(signal::AbstractMatrix, config::MTCrossSpectraConfig)\n\nComputes multitapered cross power spectra between channels of a signal. Arguments:\n\nsignal: n_channels x n_samples\nOptionally pass an MTCrossSpectraConfig object to preallocate temporary variables\n\nand choose configuration settings. Otherwise, any keyword arguments accepted by MTCrossSpectraConfig may be passed here.\n\nProduces a CrossPowerSpectra object holding the n_channels x n_channels x n_frequencies output array (accessed by power) and the corresponding frequencies (accessed by freq).\n\nSee also mt_cross_power_spectra! and MTCrossSpectraConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_cross_power_spectra!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_cross_power_spectra!","text":"mt_cross_power_spectra!(output, signal::AbstractMatrix; fs=1, kwargs...)\nmt_cross_power_spectra!(output, signal::AbstractMatrix, config::MTCrossSpectraConfig)\n\nComputes multitapered cross power spectra between channels of a signal. Arguments:\n\noutput: n_channels x n_channels x length(config.freq). Can be created by DSP.allocate_output(config).\nsignal: n_channels x n_samples\nconfig: MTCrossSpectraConfig{T}: optionally pass a MTCrossSpectraConfig to preallocate temporary and choose configuration settings. Otherwise, one may pass any keyword arguments accepted by this object.\n\nProduces a CrossPowerSpectra object holding the n_channels x n_channels x n_frequencies output array and the corresponding frequencies (accessed by freq).\n\nSee also mt_cross_power_spectra and MTCrossSpectraConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_coherence","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_coherence","text":"mt_coherence(signal::AbstractMatrix{T}; fs=1, freq_range = nothing, demean=false, kwargs...) where T\nmt_coherence(signal::AbstractMatrix, config::MTCoherenceConfig)\n\nArguments:\n\nsignal: n_channels x n_samples matrix\nOptionally pass an MTCoherenceConfig to pre-allocate temporary variables and choose configuration settings, otherwise, see MTCrossSpectraConfig for the meaning of the keyword arguments.\n\nReturns a Coherence object.\n\nSee also mt_coherence and MTCoherenceConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_coherence!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_coherence!","text":"mt_coherence!(output, signal::AbstractMatrix; fs=1, freq_range=nothing, demean=false, kwargs...)\nmt_coherence!(output, signal::AbstractMatrix, config::MTCoherenceConfig)\n\nComputes the pairwise coherences between channels.\n\noutput: n_channels x n_channels matrix \nsignal: n_samples x n_channels matrix\nconfig: optional configuration object that pre-allocates temporary variables and choose settings.\n\nReturns a Coherence object.\n\nSee also mt_coherence and MTCoherenceConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Configuration-objects","page":"Periodograms - periodogram estimation","title":"Configuration objects","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"MTConfig\nMTSpectrogramConfig\nMTCrossSpectraConfig\nMTCoherenceConfig","category":"page"},{"location":"periodograms/#DSP.Periodograms.MTConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTConfig","text":"MTConfig{T}(n_samples; fs=1,\n        nfft = nextpow(2, n_samples),\n        window = nothing,\n        nw = 4,\n        ntapers = 2 * nw - 1,\n        taper_weights = fill(1/ntapers, ntapers),\n        onesided::Bool=T<:Real,\n        fft_flags = FFTW.MEASURE)\n\nCreates a config object which holds the configuration state and temporary variables used in multitaper computations, e.g. mt_pgram!, mt_spectrogram, MTSpectrogramConfig, MTCrossSpectraConfig, and MTCoherenceConfig.\n\nAn MTConfig can be re-used between computations as long as none of the input arguments change.\n\nn_samples: the number of samples to be used as input when computing multitaper periodograms with this configuration. Used for pre-allocating temporary buffers.\nfs: the number of samples per second of the input signal\nnfft: length of input vector to the FFT; if nfft > n_samples, then the input signal will be zero-padded until it is of length nfft.\nwindow: window function to use for tapering. If left at the default of nothing, window will be set to dpss(n_samples, nw, ntapers).\nntapers: the number of tapers to use.\ntaper_weights = fill(1/ntapers, ntapers): how to weight the contribution of each taper. The default setting is to simply average them.\nonesided: whether or not to compute a \"one-sided\" FFT by using that real signal data yields conjugate-symmetry in Fourier space.\nfft_flags: flags to control how the FFT plan is generated.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTSpectrogramConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTSpectrogramConfig","text":"MTSpectrogramConfig(n_samples, mt_config::MTConfig{T}, n_overlap_samples) where {T}\nMTSpectrogramConfig{T}(n_samples, samples_per_window, n_overlap_samples; fs=1, kwargs...) where {T}\n\nCreates a MTSpectrogramConfig which holds configuration and temporary variables for mt_spectrogram and mt_spectrogram!. Any keyword arguments accepted by MTConfig may be passed here, or an MTConfig object itself.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTCrossSpectraConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTCrossSpectraConfig","text":"MTCrossSpectraConfig{T}(n_channels, n_samples; fs=1, demean=false, freq_range=nothing,\n                        ensure_aligned = T == Float32 || T == Complex{Float32}, kwargs...) where {T}\nMTCrossSpectraConfig(n_channels, mt_config::MTConfig{T}; demean=false, freq_range=nothing,\n                     ensure_aligned = T == Float32 || T == Complex{Float32})\n\nCreates a configuration object used for mt_cross_power_spectra and mt_cross_power_spectra!.\n\nn_channels: the number of channels of the input.\nn_samples: the number of samples for each channel of the input.\ndemean: if true, the channelwise mean will be subtracted from the input signals before the cross spectral powers are computed.\nfreq_range: if nothing, all frequencies are retained. Otherwise, only frequencies between first(freq_range) and last(freq_range) are retained.\nensure_aligned = T == Float32 || T == Complex{Float32}: perform an extra copy to ensure that the FFT output is memory-aligned\nAdditionally, either pass an MTConfig object, or keyword arguments such as fs accepted by MTConfig.\n\nReturns a CrossPowerSpectra object.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTCoherenceConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTCoherenceConfig","text":"MTCoherenceConfig{T}(n_channels, n_samples; fs=1, demean=false, freq_range=nothing, kwargs...) where T\nMTCoherenceConfig(cs_config::MTCrossSpectraConfig{T}) where {T}\nMTCoherenceConfig(n_channels, mt_config::MTConfig{T}; demean=false, freq_range=nothing,\n    ensure_aligned = T == Float32 || T == Complex{Float32}) where {T}\n\nCreates a configuration object for coherences from a MTCrossSpectraConfig. Provides a helper method with the same arugments as MTCrossSpectraConfig to construct the MTCrossSpectraConfig object.\n\nSee also mt_coherence and mt_coherence!.\n\n\n\n\n\n","category":"type"},{"location":"util/#Util-utility-functions","page":"Util - utility functions","title":"Util - utility functions","text":"","category":"section"},{"location":"util/","page":"Util - utility functions","title":"Util - utility functions","text":"note: Note\nAs of version 0.6.1 of DSP.jl, fftfreq and rfftfreq have been moved from DSP.jl to AbstractFFTs.jl version 0.5 and above. You can also access these functions through FFTW.jl version 1.1 and above.","category":"page"},{"location":"util/","page":"Util - utility functions","title":"Util - utility functions","text":"unwrap\nunwrap!\nhilbert\nnextfastfft\npow2db\namp2db\ndb2pow\ndb2amp\nrms\nrmsfft\nmeanfreq\nfinddelay\nshiftsignal\nshiftsignal!\nalignsignals\nalignsignals!\ndiric","category":"page"},{"location":"util/#DSP.Unwrap.unwrap","page":"Util - utility functions","title":"DSP.Unwrap.unwrap","text":"unwrap(m; kwargs...)\n\nAssumes m to be a sequence of values that has been wrapped to be inside the given range (centered around zero), and undoes the wrapping by identifying discontinuities. If a single dimension is passed to dims, then m is assumed to have wrapping discontinuities only along that dimension. If a range of dimensions, as in 1:ndims(m), is passed to dims, then m is assumed to have wrapping discontinuities across all ndims(m) dimensions.\n\nA common usage for unwrapping across a singleton dimension is for a phase measurement over time, such as when comparing successive frames of a short-time-fourier-transform, as each frame is wrapped to stay within (-pi, pi].\n\nA common usage for unwrapping across multiple dimensions is for a phase measurement of a scene, such as when retrieving the phase information of of an image, as each pixel is wrapped to stay within (-pi, pi].\n\nArguments\n\nm::AbstractArray{T, N}: Array to unwrap.\ndims=nothing: Dimensions along which to unwrap. If dims is an integer, then   unwrap is called on that dimension. If dims=1:ndims(m), then m is unwrapped   across all dimensions.\nrange=2pi: Range of wrapped array.\ncircular_dims=(false, ...):  When an element of this tuple is true, the   unwrapping process will consider the edges along the corresponding axis   of the array to be connected.\nrng=GLOBAL_RNG: Unwrapping of arrays with dimension > 1 uses a random   initialization. A user can pass their own RNG through this argument.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Unwrap.unwrap!","page":"Util - utility functions","title":"DSP.Unwrap.unwrap!","text":"unwrap!(m; kwargs...)\n\nIn-place version of unwrap.\n\n\n\n\n\nunwrap!(y, m; kwargs...)\n\nUnwrap m storing the result in y, see unwrap.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.hilbert","page":"Util - utility functions","title":"DSP.Util.hilbert","text":"hilbert(x)\n\nComputes the analytic representation of x, x_a = x + j hatx, where hatx is the Hilbert transform of x, along the first dimension of x.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.nextfastfft","page":"Util - utility functions","title":"DSP.Util.nextfastfft","text":"nextfastfft(n)\n\nReturn the closest product of 2, 3, 5, and 7 greater than or equal to n. FFTW contains optimized kernels for these sizes and computes Fourier transforms of input that is a product of these sizes faster than for input of other sizes.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.pow2db","page":"Util - utility functions","title":"DSP.Util.pow2db","text":"pow2db(a)\n\nConvert a power ratio to dB (decibel), or 10log_10(a). The inverse of db2pow.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.amp2db","page":"Util - utility functions","title":"DSP.Util.amp2db","text":"amp2db(a)\n\nConvert an amplitude ratio to dB (decibel), or 20 log_10(a)=10log_10(a^2). The inverse of db2amp.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.db2pow","page":"Util - utility functions","title":"DSP.Util.db2pow","text":"db2pow(a)\n\nConvert dB to a power ratio. This function call also be called using a*dB, i.e. 3dB == db2pow(3). The inverse of pow2db.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.db2amp","page":"Util - utility functions","title":"DSP.Util.db2amp","text":"db2amp(a)\n\nConvert dB to an amplitude ratio. This function call also be called using a*dBa, i.e. 3dBa == db2amp(3). The inverse of amp2db.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.rms","page":"Util - utility functions","title":"DSP.Util.rms","text":"rms(s)\n\nReturn the root mean square of signal s.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.rmsfft","page":"Util - utility functions","title":"DSP.Util.rmsfft","text":"rmsfft(f)\n\nReturn the root mean square of signal s given the FFT transform f = fft(s). Equivalent to rms(ifft(f)).\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.meanfreq","page":"Util - utility functions","title":"DSP.Util.meanfreq","text":"meanfreq(x, fs)\n\nCalculate the mean power frequency of x with a sampling frequency of fs, defined as:\n\nMPF = fracsum_i=1^F f_i X_i^2 sum_i=0^F X_i^2  Hz\n\nwhere F is the Nyquist frequency, and X is the power spectral density.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.finddelay","page":"Util - utility functions","title":"DSP.Util.finddelay","text":"finddelay(x, y)\n\nEstimate the delay of x with respect to y by locating the peak of their cross-correlation.\n\nThe output delay will be positive when x is delayed with respect y, negative if advanced, 0 otherwise.\n\nExample\n\njulia> finddelay([0, 0, 1, 2, 3], [1, 2, 3])\n2\n\njulia> finddelay([1, 2, 3], [0, 0, 1, 2, 3])\n-2\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.shiftsignal","page":"Util - utility functions","title":"DSP.Util.shiftsignal","text":"shiftsignal(x, s)\n\nShift elements of signal x in time by a given amount s of samples and fill the spaces with zeros. For circular shifting, use circshift.\n\nExample\n\njulia> shiftsignal([1, 2, 3], 2)\n3-element Vector{Int64}:\n 0\n 0\n 1\n\njulia> shiftsignal([1, 2, 3], -2)\n3-element Vector{Int64}:\n 3\n 0\n 0\n\nSee also shiftsignal!.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.shiftsignal!","page":"Util - utility functions","title":"DSP.Util.shiftsignal!","text":"shiftsignal!(x, s)\n\nMutating version of shiftsignals(): shift x of s samples and fill the spaces with zeros in-place.\n\nSee also shiftsignal.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.alignsignals","page":"Util - utility functions","title":"DSP.Util.alignsignals","text":"alignsignals(x, y)\n\nUse finddelay() and shiftsignal() to time align x to y. Also return the delay of x with respect to y.\n\nExample\n\njulia> alignsignals([0, 0, 1, 2, 3], [1, 2, 3])\n([1, 2, 3, 0, 0], 2)\n\njulia> alignsignals([1, 2, 3], [0, 0, 1, 2, 3])\n([0, 0, 1], -2)\n\nSee also alignsignals!.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.alignsignals!","page":"Util - utility functions","title":"DSP.Util.alignsignals!","text":"alignsignals!(x, y)\n\nMutating version of alignsignals(): time align x to y in-place.\n\nSee also alignsignals.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.diric","page":"Util - utility functions","title":"DSP.diric","text":"kernel = diric(Ω::Real, n::Integer)\n\nDirichlet kernel, also known as periodic sinc function, where n should be a positive integer. Returns sin(Ω * n/2) / (n * sin(Ω / 2)) typically, but ±1 when Ω is a multiple of 2π.\n\nIn the usual case where 'n' is odd, the output is equivalent to 1n sum_k=-(n-1)2^(n-1)2 e^i k Ω, which is the discrete-time Fourier transform (DTFT) of a n-point moving average filter.\n\nWhen n is odd or even, the function is 2π or 4π periodic, respectively. The formula for general n is diric(Ω,n) =e^{-i (n-1) Ω/2}/n \\sum_{k=0}^{n-1} e^{i k Ω}, which is a real and symmetric function ofΩ`.\n\nAs of 2021-03-19, the Wikipedia definition has different factors. The definition here is consistent with scipy and other software frameworks.\n\nExamples\n\njulia> round.(diric.((-2:0.5:2)*π, 5), digits=9)'\n1×9 adjoint(::Vector{Float64}) with eltype Float64:\n 1.0  -0.2  0.2  -0.2  1.0  -0.2  0.2  -0.2  1.0\n\njulia> diric(0, 4)\n1.0\n\n\n\n\n\n","category":"function"}]
}
