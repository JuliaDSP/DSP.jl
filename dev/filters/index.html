<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Filters - filter design and filtering · DSP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DSP.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../contents/">Contents</a></li><li><a class="tocitem" href="../periodograms/"><code>Periodograms</code> - periodogram estimation</a></li><li><a class="tocitem" href="../estimation/"><code>Estimation</code> - parametric estimation functions</a></li><li><a class="tocitem" href="../windows/"><code>Windows</code> - window functions</a></li><li class="is-active"><a class="tocitem" href><code>Filters</code> - filter design and filtering</a><ul class="internal"><li><a class="tocitem" href="#coefficient-objects"><span>Filter coefficient objects</span></a></li><li><a class="tocitem" href="#stateful-filter-objects"><span>Stateful filter objects</span></a></li><li><a class="tocitem" href="#Filter-application"><span>Filter application</span></a></li><li><a class="tocitem" href="#Filter-design"><span>Filter design</span></a></li><li><a class="tocitem" href="#Filter-response"><span>Filter response</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../util/"><code>Util</code> - utility functions</a></li><li><a class="tocitem" href="../convolutions/"><code>Convolutions</code> - similarity methods</a></li><li><a class="tocitem" href="../lpc/"><code>LPC</code> - Linear Predictive Coding</a></li><li><a class="tocitem" href="../">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><code>Filters</code> - filter design and filtering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>Filters</code> - filter design and filtering</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDSP/DSP.jl/blob/master/docs/src/filters.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Filters-filter-design-and-filtering"><a class="docs-heading-anchor" href="#Filters-filter-design-and-filtering"><code>Filters</code> - filter design and filtering</a><a id="Filters-filter-design-and-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filters-filter-design-and-filtering" title="Permalink"></a></h1><p>DSP.jl differentiates between <a href="#coefficient-objects">filter coefficients</a> and <a href="#stateful-filter-objects">stateful filters</a>. Filter coefficient objects specify the response of the filter in one of several standard forms. Stateful filter objects carry the state of the filter together with filter coefficients in an implementable form (<code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>). When invoked on a filter coefficient object, <code>filt</code> does not preserve state.</p><h2 id="coefficient-objects"><a class="docs-heading-anchor" href="#coefficient-objects">Filter coefficient objects</a><a id="coefficient-objects-1"></a><a class="docs-heading-anchor-permalink" href="#coefficient-objects" title="Permalink"></a></h2><p>DSP.jl supports common filter representations. Filter coefficients can be converted from one type to another using <code>convert</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.ZeroPoleGain" href="#DSP.Filters.ZeroPoleGain"><code>DSP.Filters.ZeroPoleGain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZeroPoleGain(z, p, k)</code></pre><p>Filter representation in terms of zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code>:</p><p class="math-container">\[H(x) = k\frac{(x - \verb!z[1]!) \ldots (x - \verb!z[m]!)}{(x - \verb!p[1]!) \ldots (x - \verb!p[n]!)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.PolynomialRatio" href="#DSP.Filters.PolynomialRatio"><code>DSP.Filters.PolynomialRatio</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolynomialRatio(b, a)</code></pre><p>Filter representation in terms of the coefficients of the numerator <code>b</code> and denominator <code>a</code> of the transfer function:</p><p class="math-container">\[H(s) = \frac{\verb!b[1]! s^{m-1} + \ldots + \verb!b[m]!}{\verb!a[1]! s^{n-1} + \ldots + \verb!a[n]!}\]</p><p>or equivalently:</p><p class="math-container">\[H(z) = \frac{\verb!b[1]! + \ldots + \verb!b[n]! z^{-n+1}}{\verb!a[1]! + \ldots + \verb!a[n]! z^{-n+1}}\]</p><p><code>b</code> and <code>a</code> may be specified as <code>Polynomial</code> objects or vectors ordered from highest power to lowest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Biquad" href="#DSP.Filters.Biquad"><code>DSP.Filters.Biquad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Biquad(b0, b1, b2, a1, a2)</code></pre><p>Filter representation in terms of the transfer function of a single second-order section given by:</p><p class="math-container">\[H(s) = \frac{\verb!b0! s^2+\verb!b1! s+\verb!b2!}{s^2+\verb!a1! s + \verb!a2!}\]</p><p>or equivalently:</p><p class="math-container">\[H(z) = \frac{\verb!b0!+\verb!b1! z^{-1}+\verb!b2! z^{-2}}{1+\verb!a1! z^{-1} + \verb!a2! z^{-2}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L192-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.SecondOrderSections" href="#DSP.Filters.SecondOrderSections"><code>DSP.Filters.SecondOrderSections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SecondOrderSections(biquads, gain)</code></pre><p>Filter representation in terms of a cascade of second-order sections and gain. <code>biquads</code> must be specified as a vector of <code>Biquads</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L258-L264">source</a></section></article><p>These filter coefficient objects support the following arithmetic operations: inversion (<code>inv</code>), multiplication (<code>*</code>) for series connection, and integral power (<code>^</code>) for repeated mutlpilcation with itself. For example:</p><pre><code class="language-julia-repl">julia&gt; H = PolynomialRatio([1.0], [1.0, 0.3])
PolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.3*z⁻¹ + 1.0))

julia&gt; inv(H)
PolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(0.3*z⁻¹ + 1.0), Polynomials.LaurentPolynomial(1.0))

julia&gt; H * H
PolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))

julia&gt; H^2
PolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(1.0), Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))

julia&gt; H^-2
PolynomialRatio{:z, Float64}(Polynomials.LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0), Polynomials.LaurentPolynomial(1.0))
</code></pre><h2 id="stateful-filter-objects"><a class="docs-heading-anchor" href="#stateful-filter-objects">Stateful filter objects</a><a id="stateful-filter-objects-1"></a><a class="docs-heading-anchor-permalink" href="#stateful-filter-objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.DF2TFilter" href="#DSP.Filters.DF2TFilter"><code>DSP.Filters.DF2TFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DF2TFilter(coef[, si])</code></pre><p>Construct a stateful direct form II transposed filter with coefficients <code>coef</code>. <code>si</code> is an optional array representing the initial filter state (defaults to zeros). If <code>f</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>f</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L122-L131">source</a></section></article><p>DSP.jl&#39;s <code>FIRFilter</code> type maintains state between calls to <a href="#DSP.filt"><code>filt</code></a>, allowing you to filter a signal of indefinite length in RAM-friendly chunks. <code>FIRFilter</code> contains nothing more that the state of the filter, and a <code>FIRKernel</code>. There are five different kinds of <code>FIRKernel</code> for single rate, up-sampling, down-sampling, rational resampling, and arbitrary sample-rate conversion. You need not specify the type of kernel. The <code>FIRFilter</code> constructor selects the correct kernel based on input parameters.</p><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.FIRFilter" href="#DSP.Filters.FIRFilter"><code>DSP.Filters.FIRFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FIRFilter(h[, ratio])</code></pre><p>Construct a stateful FIRFilter object from the vector of filter taps <code>h</code>. <code>ratio</code> is an optional rational integer which specifies the input to output sample rate relationship (e.g. <code>147//160</code> for converting recorded audio from 48 KHz to 44.1 KHz).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/stream_filt.jl#L148-L155">source</a></section><section><div><pre><code class="language-none">FIRFilter(h, rate[, Nϕ])</code></pre><p>Returns a polyphase FIRFilter object from the vector of filter taps <code>h</code>. <code>rate</code> is a floating point number that specifies the input to output sample-rate relationship <span>$\frac{fs_{out}}{fs_{in}}$</span>. <code>Nϕ</code> is an optional parameter which specifies the number of <em>phases</em> created from <code>h</code>. <code>Nϕ</code> defaults to 32.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/stream_filt.jl#L181-L189">source</a></section></article><h2 id="Filter-application"><a class="docs-heading-anchor" href="#Filter-application">Filter application</a><a id="Filter-application-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-application" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSP.filt" href="#DSP.filt"><code>DSP.filt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filt(b, a, x, [si])</code></pre><p>Apply filter described by vectors <code>a</code> and <code>b</code> to vector <code>x</code>, with an optional initial filter state vector <code>si</code> (defaults to zeros).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/dspbase.jl#L10-L15">source</a></section><section><div><pre><code class="language-none">filt(f, x[, si])</code></pre><p>Apply filter or filter coefficients <code>f</code> along the first dimension of array <code>x</code>. If <code>f</code> is a filter coefficient object, <code>si</code> is an optional array representing the initial filter state (defaults to zeros). If <code>f</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>f</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.  If <code>f</code> is a Vector, it is interpreted as an FIR filter, and a naïve or FFT-based algorithm is selected based on the data and filter length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.filt!" href="#DSP.filt!"><code>DSP.filt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filt!(out, b, a, x, [si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt</code></a> but writes the result into the <code>out</code> argument, which may alias the input <code>x</code> to modify it in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/dspbase.jl#L24-L29">source</a></section><section><div><pre><code class="language-none">filt!(out, f, x[, si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt()</code></a> but writes the result into the <code>out</code> argument. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.filtfilt" href="#DSP.Filters.filtfilt"><code>DSP.Filters.filtfilt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filtfilt(coef, x)</code></pre><p>Filter <code>x</code> in the forward and reverse directions using filter coefficients <code>coef</code>. The initial state of the filter is computed so that its response to a step function is steady state. Before filtering, the data is extrapolated at both ends with an odd-symmetric extension of length <code>3*(max(length(b), length(a))-1)</code>.</p><p>Because <code>filtfilt</code> applies the given filter twice, the effective filter order is twice the order of <code>coef</code>. The resulting signal has zero phase distortion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L258-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.fftfilt" href="#DSP.Filters.fftfilt"><code>DSP.Filters.fftfilt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftfilt(h, x)</code></pre><p>Apply FIR filter taps <code>h</code> along the first dimension of array <code>x</code> using an FFT-based overlap-save algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.fftfilt!" href="#DSP.Filters.fftfilt!"><code>DSP.Filters.fftfilt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftfilt!(out, h, x)</code></pre><p>Like <code>fftfilt</code> but writes result into out array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.tdfilt" href="#DSP.Filters.tdfilt"><code>DSP.Filters.tdfilt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tdfilt(h, x)</code></pre><p>Apply filter or filter coefficients <code>h</code> along the first dimension of array <code>x</code> using a naïve time-domain algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L388-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.tdfilt!" href="#DSP.Filters.tdfilt!"><code>DSP.Filters.tdfilt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tdfilt!(out, h, x)</code></pre><p>Like <code>tdfilt</code>, but writes the result into array <code>out</code>. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/filt.jl#L398-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample" href="#DSP.Filters.resample"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resample(x, rate[, coef])</code></pre><p>Resample <code>x</code> at rational or arbitrary <code>rate</code>. <code>coef</code> is an optional vector of FIR filter taps. If <code>coef</code> is not provided, the taps will be computed using a Kaiser window.</p><p>Internally, <code>resample</code> uses a polyphase <code>FIRFilter</code> object, but performs additional operations to make resampling a signal easier. It compensates for the <code>FIRFilter</code>&#39;s delay (ramp-up), and appends zeros to <code>x</code>. The result is that when the input and output signals are plotted on top of each other, they correlate very well, but one signal will have more samples that the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/stream_filt.jl#L697-L710">source</a></section><section><div><pre><code class="language-none">resample(x::AbstractMatrix, rate::Real, h::Vector = resample_filter(rate); dims)</code></pre><p>Resample a matrix <code>x</code> along dimension <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/stream_filt.jl#L736-L740">source</a></section></article><h2 id="Filter-design"><a class="docs-heading-anchor" href="#Filter-design">Filter design</a><a id="Filter-design-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-design" title="Permalink"></a></h2><p>Most analog and digital filters are constructed by composing <a href="#response-types">response types</a>, which determine the frequency response of the filter, with <a href="#design-methods">design methods</a>, which determine how the filter is constructed. The response type is <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a>, <a href="#DSP.Filters.Highpass"><code>Highpass</code></a>, <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> or <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> and includes the edges of the bands. The design method is <a href="#DSP.Filters.Butterworth"><code>Butterworth</code></a>, <a href="#DSP.Filters.Chebyshev1"><code>Chebyshev1</code></a>, <a href="#DSP.Filters.Chebyshev2"><code>Chebyshev2</code></a>,  <a href="#DSP.Filters.Elliptic"><code>Elliptic</code></a>, or <a href="#DSP.Filters.FIRWindow"><code>FIRWindow</code></a>, and includes any necessary parameters for the method that affect the shape of the response, such as filter order, ripple, and attenuation.</p><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.analogfilter" href="#DSP.Filters.analogfilter"><code>DSP.Filters.analogfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analogfilter(responsetype, designmethod)</code></pre><p>Construct an analog filter. See below for possible response and filter types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.digitalfilter" href="#DSP.Filters.digitalfilter"><code>DSP.Filters.digitalfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">digitalfilter(responsetype, designmethod)</code></pre><p>Construct a digital filter. See below for possible response and filter types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L455-L460">source</a></section></article><p>For some filters, the design method is more general or  inherently implies a response type; these <a href="#direct-design-methods">direct design methods</a> include <a href="#DSP.Filters.remez"><code>remez</code></a> which designs equiripple FIR filters of all types, and <a href="#DSP.Filters.iirnotch"><code>iirnotch</code></a> which designs a  2nd order &quot;biquad&quot; IIR notch filter.</p><h3 id="response-types"><a class="docs-heading-anchor" href="#response-types">Filter response types</a><a id="response-types-1"></a><a class="docs-heading-anchor-permalink" href="#response-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Lowpass" href="#DSP.Filters.Lowpass"><code>DSP.Filters.Lowpass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lowpass(Wn[; fs])</code></pre><p>Low pass filter with cutoff frequency <code>Wn</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L249-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Highpass" href="#DSP.Filters.Highpass"><code>DSP.Filters.Highpass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Highpass(Wn[; fs])</code></pre><p>High pass filter with cutoff frequency <code>Wn</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Bandpass" href="#DSP.Filters.Bandpass"><code>DSP.Filters.Bandpass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bandpass(Wn1, Wn2[; fs])</code></pre><p>Band pass filter with normalized pass band (<code>Wn1</code>, <code>Wn2</code>). If <code>fs</code> is not specified, <code>Wn1</code> and <code>Wn2</code> are interpreted as normalized frequencies in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L276-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Bandstop" href="#DSP.Filters.Bandstop"><code>DSP.Filters.Bandstop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bandstop(Wn1, Wn2[; fs])</code></pre><p>Band stop filter with normalized stop band (<code>Wn1</code>, <code>Wn2</code>). If <code>fs</code> is not specified, <code>Wn1</code> and <code>Wn2</code> are interpreted as normalized frequencies in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L293-L299">source</a></section></article><h3 id="design-methods"><a class="docs-heading-anchor" href="#design-methods">Filter design methods</a><a id="design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#design-methods" title="Permalink"></a></h3><h4 id="IIR-filter-design-methods"><a class="docs-heading-anchor" href="#IIR-filter-design-methods">IIR filter design methods</a><a id="IIR-filter-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#IIR-filter-design-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Butterworth" href="#DSP.Filters.Butterworth"><code>DSP.Filters.Butterworth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Butterworth(n)</code></pre><p><span>$n$</span> pole Butterworth filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Chebyshev1" href="#DSP.Filters.Chebyshev1"><code>DSP.Filters.Chebyshev1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Chebyshev1(n, ripple)</code></pre><p><code>n</code> pole Chebyshev type I filter with <code>ripple</code> dB ripple in the passband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Chebyshev2" href="#DSP.Filters.Chebyshev2"><code>DSP.Filters.Chebyshev2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Chebyshev2(n, ripple)</code></pre><p><code>n</code> pole Chebyshev type II filter with <code>ripple</code> dB ripple in the stopband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.Elliptic" href="#DSP.Filters.Elliptic"><code>DSP.Filters.Elliptic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Elliptic(n, rp, rs)</code></pre><p><code>n</code> pole elliptic (Cauer) filter with <code>rp</code> dB ripple in the passband and <code>rs</code> dB attentuation in the stopband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L225-L230">source</a></section></article><h4 id="FIR-filter-design-methods"><a class="docs-heading-anchor" href="#FIR-filter-design-methods">FIR filter design methods</a><a id="FIR-filter-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#FIR-filter-design-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.FIRWindow" href="#DSP.Filters.FIRWindow"><code>DSP.Filters.FIRWindow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FIRWindow(window; scale=true)</code></pre><p>FIR filter design using window <code>window</code>, a vector whose length matches the number of taps in the resulting filter.</p><p>If <code>scale</code> is <code>true</code> (default), the designed FIR filter is scaled so that the following holds:</p><ul><li>For <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a> and <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> filters, the frequency response is unity at 0 (DC).</li><li>For <a href="#DSP.Filters.Highpass"><code>Highpass</code></a> filters, the frequency response is unity at the Nyquist frequency.</li><li>For <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> filters, the frequency response is unity in the center of the passband.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L513-L528">source</a></section><section><div><pre><code class="language-none">FIRWindow(; transitionwidth, attenuation=60, scale=true)</code></pre><p>Kaiser window FIR filter design. The required number of taps is calculated based on <code>transitionwidth</code> (in half-cycles/sample) and stopband <code>attenuation</code> (in dB). <code>attenuation</code> defaults to 60 dB.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L532-L539">source</a></section></article><h3 id="direct-design-methods"><a class="docs-heading-anchor" href="#direct-design-methods">Direct filter design methods</a><a id="direct-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#direct-design-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.remez" href="#DSP.Filters.remez"><code>DSP.Filters.remez</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remez(numtaps::Integer, band_defs;
      Hz::Real=1.0,
      neg::Bool=false,
      maxiter::Integer=25,
      grid_density::Integer=16)</code></pre><p>Calculate the minimax optimal filter using the Remez exchange algorithm <sup class="footnote-reference"><a id="citeref-McClellan1973a" href="#footnote-McClellan1973a">[McClellan1973a]</a></sup> <sup class="footnote-reference"><a id="citeref-McClellan1973b" href="#footnote-McClellan1973b">[McClellan1973b]</a></sup>.</p><p>This is the simplified API that accepts just 2 required arguments (numtaps, band_defs). For a scipy compatible version see the 3 arguments version (numtaps, bands, desired). </p><p>Calculate the filter-coefficients for the finite impulse response (FIR) filter whose transfer function minimizes the maximum error between the desired gain and the realized gain in the specified frequency bands using the Remez exchange algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>numtaps::Integer</code>: The desired number of taps in the filter.    The number of taps is the number of terms in the filter, or the filter    order plus one.</li><li><code>bands_defs</code>: A sequence of band definitions.   This sequence defines the bands. Each entry is a pair. The pair&#39;s   first item is a tuple of band edges (low, high). The pair&#39;s second item    defines the desired response and weight in that band. The weight is optional   and defaults to 1.0. Both the desired response and weight may be either scalars   or functions. If a function, the function should accept a real frequency and   return the real desired response or real weight. Examples:<ul><li>LPF with unity weights. <code>[(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]</code></li><li>LPF with weight of 2 in the stop band. <code>[(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]</code></li><li>BPF with unity weights. <code>[(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]</code></li><li>Hilbert transformer. <code>[(0.1, 0.95) =&gt; 1]; neg=true</code></li><li>Differentiator. <code>[(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true</code></li></ul></li><li><code>Hz::Real</code>: The sampling frequency in Hz. Default is 1.</li><li><code>neg::Bool</code>: Whether the filter has negative symmetry or not. Default is false.   If false, the filter is even-symmetric. If true, the filter is odd-symmetric.   neg=true means that h[n]=-h[end+1-n]; neg=false means that h[n]=h[end+1-n].</li><li><code>maxiter::Integer</code>: (optional)   Maximum number of iterations of the algorithm. Default is 25.</li><li><code>grid_density:Integer</code>: (optional)   Grid density. The dense grid used in <code>remez</code> is of size   <code>(numtaps + 1) * grid_density</code>. Default is 16.</li></ul><p><strong>Returns</strong></p><ul><li><code>h::Array{Float64,1}</code>: A rank-1 array containing the coefficients of the optimal   (in a minimax sense) filter.</li></ul><p>J. H. McClellan and T. W. Parks, A unified approach to the design of optimum FIR linear phase digital filters, IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.</p><p>J. H. McClellan, T. W. Parks and L. R. Rabiner, A Computer Program for Designing Optimum FIR Linear Phase Digital Filters, IEEE Trans. Audio Electroacoust., vol. AU-21, pp. 506-525, 1973.</p><p><strong>Examples</strong></p><p>Construct a length 35 filter with a passband at 0.15-0.4 Hz  (desired response of 1), and stop bands at 0-0.1 Hz and 0.45-0.5 Hz (desired response of 0). Note: the behavior in the frequency ranges between  those bands - the transition bands - is unspecified.</p><pre><code class="language-julia-repl">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);</code></pre><p>You can trade-off maximum error achieved for transition bandwidth.  The wider the transition bands, the lower the maximum error in the bands specified. Here is a bandpass filter with the same passband, but wider transition bands.</p><pre><code class="language-julia-repl">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);</code></pre><p>Here we compute the frequency responses and plot them in dB.</p><pre><code class="language-julia-repl">julia&gt; using PyPlot
julia&gt; b = DSP.Filters.PolynomialRatio(bpass, [1.0])
julia&gt; b2 = DSP.Filters.PolynomialRatio(bpass2, [1.0])
julia&gt; f = range(0, stop=0.5, length=1000)
julia&gt; plot(f, 20*log10.(abs.(freqresp(b,f,1.0))))
julia&gt; plot(f, 20*log10.(abs.(freqresp(b2,f,1.0))))
julia&gt; grid()</code></pre><p><strong>Examples from the unittests - standard (even) symmetry.</strong></p><p>Length 151 LPF (Low Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(151, [(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]; Hz=2.0);</code></pre><p>Length 152 LPF. Non-default &quot;weight&quot; input.</p><pre><code class="language-julia-repl">julia&gt; h = remez(152, [(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]; Hz=2.0);</code></pre><p>Length 51 HPF (High Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(51, [(0, 0.75) =&gt; 0, (0.8, 1.0) =&gt; 1]; Hz=2.0);</code></pre><p>Length 180 BPF (Band Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(180, [(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]; Hz=2.0, maxiter=30);</code></pre><p><strong>Examples from the unittests - Odd-symmetric filters - hilbert and differentiators type.</strong></p><p>Even length - has a much better approximation since the response is not constrained to 0 at the nyquist frequency.  Length 20 Hilbert transformer.</p><pre><code class="language-julia-repl">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 21 Hilbert transformer.</p><pre><code class="language-julia-repl">julia&gt; h = remez(21, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 200 differentiator.</p><pre><code class="language-julia-repl">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Length 201 differentiator.</p><pre><code class="language-julia-repl">julia&gt; h = remez(201, [(0.05, 0.95) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Inverse sinc filter - custom response function</p><pre><code class="language-julia-repl">julia&gt; L = 64; Fs = 4800*L;
julia&gt; passband_response_function = f -&gt; (f==0) ? 1.0 : abs.((π*f/4800) ./ sin.(π*f/4800));
julia&gt; h = remez(201, [(    0.0, 2880.0) =&gt; (passband_response_function, 1.0),
                (10000.0,   Fs/2) =&gt; (0.0, 100.0)]; Hz=Fs);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/remez_fir.jl#L256-L396">source</a></section><section><div><pre><code class="language-none">remez(numtaps::Integer, 
      bands::Vector, 
      desired::Vector; 
      weight::Vector=[], 
      Hz::Real=1.0, 
      filter_type::RemezFilterType=filter_type_bandpass,
      maxiter::Integer=25, 
      grid_density::Integer=16)</code></pre><p>This is the scipy compatible version that requires 3 arguments (numtaps, bands, desired).  For a simplified API, see the 2 argument version (numtaps, band_defs). The filters designed are equivalent, the inputs are just specified in a different way. Below the arguments and examples are described that differ from the simplified API version.</p><p><strong>Arguments</strong></p><ul><li><code>bands::Vector</code>: A monotonic sequence containing the band edges in Hz.   All elements must be non-negative and less than half the sampling   frequency as given by <code>Hz</code>.</li><li><code>desired::Vector</code>:A sequence half the size of bands containing the desired    gain in each of the specified bands.</li><li><code>weight::Vector</code>: (optional)   A relative weighting to give to each band region. The length of   <code>weight</code> has to be half the length of <code>bands</code>.</li><li><code>filter_type::RemezFilterType</code>: Default is <code>filter_type_bandpass</code>.   The type of filter:<ul><li><code>filter_type_bandpass</code> : flat response in bands. This is the default.</li><li><code>filter_type_differentiator</code> : frequency proportional response in bands.   Odd symetric as in <code>filter_type_hilbert</code> case, but with a linear sloping   desired response.</li><li><code>filter_type_hilbert</code> : filter with odd symmetry, that is, type III             (for even order) or type IV (for odd order)             linear phase filters.</li></ul></li></ul><p><strong>Examples</strong></p><p>Compare the examples with the simplified API and the Scipy API. Each of the following blocks first designs a filter using the  simplified (recommended) API, and then designs the same filter using the Scipy-compatible API.</p><pre><code class="language-julia-repl">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);

julia&gt; bpass = remez(35, [0, 0.1, 0.15, 0.4, 0.45, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);

julia&gt; bpass2 = remez(35, [0, 0.08, 0.15, 0.4, 0.47, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);

julia&gt; h = remez(20, [0.1, 0.95], [1]; filter_type=filter_type_hilbert, Hz=2.0);
</code></pre><pre><code class="language-julia-repl">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);

julia&gt; h = remez(200, [0.01, 0.99], [1]; filter_type=filter_type_differentiator, Hz=2.0);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/remez_fir.jl#L771-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.iirnotch" href="#DSP.Filters.iirnotch"><code>DSP.Filters.iirnotch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iirnotch(Wn, bandwidth[; fs])</code></pre><p>Second-order digital IIR notch filter <sup class="footnote-reference"><a id="citeref-Orfandis" href="#footnote-Orfandis">[Orfandis]</a></sup> at frequency <code>Wn</code> with bandwidth <code>bandwidth</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/design.jl#L468-L476">source</a></section></article><h2 id="Filter-response"><a class="docs-heading-anchor" href="#Filter-response">Filter response</a><a id="Filter-response-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-response" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.freqresp" href="#DSP.Filters.freqresp"><code>DSP.Filters.freqresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">H, w = freqresp(filter)</code></pre><p>Frequency response <code>H</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L9-L15">source</a></section><section><div><pre><code class="language-none">freqresp(filter::FilterCoefficients{:z}, w)</code></pre><p>Frequency response of digital <code>filter</code> at normalized frequency or frequencies <code>w</code> in radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L21-L26">source</a></section><section><div><pre><code class="language-none">freqresp(filter::FilterCoefficients{:s}, w)</code></pre><p>Frequency response of analog <code>filter</code> at frequency or frequencies <code>w</code> in radians/second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.phaseresp" href="#DSP.Filters.phaseresp"><code>DSP.Filters.phaseresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phi, w = phaseresp(filter)</code></pre><p>Phase response <code>phi</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L51-L57">source</a></section><section><div><pre><code class="language-none">phaseresp(filter, w)</code></pre><p>Phase response of a <code>filter</code> at (normalized) frequency or frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.grpdelay" href="#DSP.Filters.grpdelay"><code>DSP.Filters.grpdelay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tau, w = grpdelay(filter)</code></pre><p>Group delay <code>tau</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L74-L80">source</a></section><section><div><pre><code class="language-none">grpdelay(fliter, w)</code></pre><p>Group delay of a digital &#39;filter&#39; at normalized frequency or frequencies &#39;w&#39; in radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.impresp" href="#DSP.Filters.impresp"><code>DSP.Filters.impresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impresp(filter, n=100)</code></pre><p>Impulse response of a digital <code>filter</code> with <code>n</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.stepresp" href="#DSP.Filters.stepresp"><code>DSP.Filters.stepresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stepresp(filter, n=100)</code></pre><p>Step response of a digital <code>filter</code> with <code>n</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/response.jl#L128-L132">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.coefb" href="#DSP.Filters.coefb"><code>DSP.Filters.coefb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coefb(f)</code></pre><p>Coefficients of the numerator of a PolynomialRatio object, highest power first, i.e., the <code>b</code> passed to <code>filt()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.coefa" href="#DSP.Filters.coefa"><code>DSP.Filters.coefa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coefa(f)</code></pre><p>Coefficients of the denominator of a PolynomialRatio object, highest power first, i.e., the <code>a</code> passed to <code>filt()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/6a904b3b3efed5557f4c4b6391c931a23c807514/src/Filters/coefficients.jl#L178-L183">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Construct a 4th order elliptic lowpass filter with normalized cutoff frequency 0.2, 0.5 dB of passband ripple, and 30 dB attentuation in the stopband and extract the coefficients of the numerator and denominator of the transfer function:</p><pre><code class="language-julia">responsetype = Lowpass(0.2)
designmethod = Elliptic(4, 0.5, 30)
tf = convert(PolynomialRatio, digitalfilter(responsetype, designmethod))
numerator_coefs = coefb(tf)
denominator_coefs = coefa(tf)</code></pre><p>Filter the data in <code>x</code>, sampled at 1000 Hz, with a 4th order Butterworth bandpass filter between 10 and 40 Hz:</p><pre><code class="language-julia">responsetype = Bandpass(10, 40; fs=1000)
designmethod = Butterworth(4)
filt(digitalfilter(responsetype, designmethod), x)</code></pre><p>Filter the data in <code>x</code>, sampled at 50 Hz, with a 64 tap Hanning window FIR lowpass filter at 5 Hz:</p><pre><code class="language-julia">responsetype = Lowpass(5; fs=50)
designmethod = FIRWindow(hanning(64))
filt(digitalfilter(responsetype, designmethod), x)</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-McClellan1973a"><a class="tag is-link" href="#citeref-McClellan1973a">McClellan1973a</a></li><li class="footnote" id="footnote-McClellan1973b"><a class="tag is-link" href="#citeref-McClellan1973b">McClellan1973b</a></li><li class="footnote" id="footnote-Orfandis"><a class="tag is-link" href="#citeref-Orfandis">Orfandis</a>Orfanidis, S. J. (1996). Introduction to signal processing. Englewood Cliffs, N.J: Prentice Hall, p. 370.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../windows/">« <code>Windows</code> - window functions</a><a class="docs-footer-nextpage" href="../util/"><code>Util</code> - utility functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 21 June 2021 15:47">Monday 21 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
