<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Filters - filter design and filtering · DSP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DSP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../contents/">Contents</a></li><li><a class="toctext" href="../periodograms/"><code>Periodograms</code> - periodogram estimation</a></li><li><a class="toctext" href="../estimation/"><code>Estimation</code> - parametric estimation functions</a></li><li><a class="toctext" href="../windows/"><code>Windows</code> - window functions</a></li><li class="current"><a class="toctext" href><code>Filters</code> - filter design and filtering</a><ul class="internal"><li><a class="toctext" href="#coefficient-objects-1">Filter coefficient objects</a></li><li><a class="toctext" href="#stateful-filter-objects-1">Stateful filter objects</a></li><li><a class="toctext" href="#Filter-application-1">Filter application</a></li><li><a class="toctext" href="#Filter-design-1">Filter design</a></li><li><a class="toctext" href="#Filter-response-1">Filter response</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li></ul></li><li><a class="toctext" href="../util/"><code>Util</code> - utility functions</a></li><li><a class="toctext" href="../convolutions/"><code>Convolutions</code> - similarity methods</a></li><li><a class="toctext" href="../lpc/"><code>LPC</code> - Linear Predictive Coding</a></li><li><a class="toctext" href="../">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href><code>Filters</code> - filter design and filtering</a></li></ul><a class="edit-page" href="https://github.com/JuliaDSP/DSP.jl/blob/master/docs/src/filters.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Filters - filter design and filtering</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Filters-filter-design-and-filtering-1" href="#Filters-filter-design-and-filtering-1"><code>Filters</code> - filter design and filtering</a></h1><p>DSP.jl differentiates between <a href="#coefficient-objects-1">filter coefficients</a> and <a href="#stateful-filter-objects-1">stateful filters</a>. Filter coefficient objects specify the response of the filter in one of several standard forms. Stateful filter objects carry the state of the filter together with filter coefficients in an implementable form (<code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>). When invoked on a filter coefficient object, <code>filt</code> does not preserve state.</p><h2><a class="nav-anchor" id="coefficient-objects-1" href="#coefficient-objects-1">Filter coefficient objects</a></h2><p>DSP.jl supports common filter representations. Filter coefficients can be converted from one type to another using <code>convert</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.ZeroPoleGain" href="#DSP.Filters.ZeroPoleGain"><code>DSP.Filters.ZeroPoleGain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ZeroPoleGain(z, p, k)</code></pre><p>Filter representation in terms of zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code>:</p><div>\[H(x) = k\frac{(x - \verb!z[1]!) \ldots (x - \verb!z[m]!)}{(x - \verb!p[1]!) \ldots (x - \verb!p[n]!)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L12-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.PolynomialRatio" href="#DSP.Filters.PolynomialRatio"><code>DSP.Filters.PolynomialRatio</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolynomialRatio(b, a)</code></pre><p>Filter representation in terms of the coefficients of the numerator <code>b</code> and denominator <code>a</code> of the transfer function:</p><div>\[H(s) = \frac{\verb!b[1]! s^{m-1} + \ldots + \verb!b[m]!}{\verb!a[1]! s^{n-1} + \ldots + \verb!a[n]!}\]</div><p>or equivalently:</p><div>\[H(z) = \frac{\verb!b[1]! + \ldots + \verb!b[n]! z^{-n+1}}{\verb!a[1]! + \ldots + \verb!a[n]! z^{-n+1}}\]</div><p><code>b</code> and <code>a</code> may be specified as <code>Polynomial</code> objects or vectors ordered from highest power to lowest.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L51-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Biquad" href="#DSP.Filters.Biquad"><code>DSP.Filters.Biquad</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Biquad(b0, b1, b2, a1, a2)</code></pre><p>Filter representation in terms of the transfer function of a single second-order section given by:</p><div>\[H(s) = \frac{\verb!b0! s^2+\verb!b1! s+\verb!b2!}{s^2+\verb!a1! s + \verb!a2!}\]</div><p>or equivalently:</p><div>\[H(z) = \frac{\verb!b0!+\verb!b1! z^{-1}+\verb!b2! z^{-2}}{1+\verb!a1! z^{-1} + \verb!a2! z^{-2}}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L127-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.SecondOrderSections" href="#DSP.Filters.SecondOrderSections"><code>DSP.Filters.SecondOrderSections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SecondOrderSections(biquads, gain)</code></pre><p>Filter representation in terms of a cascade of second-order sections and gain. <code>biquads</code> must be specified as a vector of <code>Biquads</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L203-L209">source</a></section><h2><a class="nav-anchor" id="stateful-filter-objects-1" href="#stateful-filter-objects-1">Stateful filter objects</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.DF2TFilter" href="#DSP.Filters.DF2TFilter"><code>DSP.Filters.DF2TFilter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DF2TFilter(coef[, si])</code></pre><p>Construct a stateful direct form II transposed filter with coefficients <code>coef</code>. <code>si</code> is an optional array representing the initial filter state (defaults to zeros). If <code>f</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>f</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L122-L131">source</a></section><p>DSP.jl&#39;s <code>FIRFilter</code> type maintains state between calls to <a href="#DSP.filt"><code>filt</code></a>, allowing you to filter a signal of indefinite length in RAM-friendly chunks. <code>FIRFilter</code> contains nothing more that the state of the filter, and a <code>FIRKernel</code>. There are five different kinds of <code>FIRKernel</code> for single rate, up-sampling, down-sampling, rational resampling, and arbitrary sample-rate conversion. You need not specify the type of kernel. The <code>FIRFilter</code> constructor selects the correct kernel based on input parameters.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.FIRFilter" href="#DSP.Filters.FIRFilter"><code>DSP.Filters.FIRFilter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FIRFilter(h[, ratio])</code></pre><p>Construct a stateful FIRFilter object from the vector of filter taps <code>h</code>. <code>ratio</code> is an optional rational integer which specifies the input to output sample rate relationship (e.g. <code>147//160</code> for converting recorded audio from 48 KHz to 44.1 KHz).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/stream_filt.jl#L133-L140">source</a><div><div><pre><code class="language-none">FIRFilter(h, rate[, Nϕ])</code></pre><p>Returns a polyphase FIRFilter object from the vector of filter taps <code>h</code>. <code>rate</code> is a floating point number that specifies the input to output sample-rate relationship <span>$\frac{fs_{out}}{fs_{in}}$</span>. <code>Nϕ</code> is an optional parameter which specifies the number of <em>phases</em> created from <code>h</code>. <code>Nϕ</code> defaults to 32.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/stream_filt.jl#L166-L174">source</a></section><h2><a class="nav-anchor" id="Filter-application-1" href="#Filter-application-1">Filter application</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.filt" href="#DSP.filt"><code>DSP.filt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filt(b, a, x, [si])</code></pre><p>Apply filter described by vectors <code>a</code> and <code>b</code> to vector <code>x</code>, with an optional initial filter state vector <code>si</code> (defaults to zeros).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/dspbase.jl#L8-L13">source</a><div><div><pre><code class="language-none">filt(f, x[, si])</code></pre><p>Apply filter or filter coefficients <code>f</code> along the first dimension of array <code>x</code>. If <code>f</code> is a filter coefficient object, <code>si</code> is an optional array representing the initial filter state (defaults to zeros). If <code>f</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>f</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.  If <code>f</code> is a Vector, it is interpreted as an FIR filter, and a naïve or FFT-based algorithm is selected based on the data and filter length.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L22-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.filt!" href="#DSP.filt!"><code>DSP.filt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filt!(out, b, a, x, [si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt</code></a> but writes the result into the <code>out</code> argument, which may alias the input <code>x</code> to modify it in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/dspbase.jl#L22-L27">source</a><div><div><pre><code class="language-none">filt!(out, f, x[, si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt()</code></a> but writes the result into the <code>out</code> argument. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.filtfilt" href="#DSP.Filters.filtfilt"><code>DSP.Filters.filtfilt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filtfilt(coef, x)</code></pre><p>Filter <code>x</code> in the forward and reverse directions using filter coefficients <code>coef</code>. The initial state of the filter is computed so that its response to a step function is steady state. Before filtering, the data is extrapolated at both ends with an odd-symmetric extension of length <code>3*(max(length(b), length(a))-1)</code>.</p><p>Because <code>filtfilt</code> applies the given filter twice, the effective filter order is twice the order of <code>coef</code>. The resulting signal has zero phase distortion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L260-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.fftfilt" href="#DSP.Filters.fftfilt"><code>DSP.Filters.fftfilt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fftfilt(h, x)</code></pre><p>Apply FIR filter taps <code>h</code> along the first dimension of array <code>x</code> using an FFT-based overlap-save algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L516-L521">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.fftfilt!" href="#DSP.Filters.fftfilt!"><code>DSP.Filters.fftfilt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fftfilt!(out, h, x)</code></pre><p>Like <code>fftfilt</code> but writes result into out array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L527-L531">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.tdfilt" href="#DSP.Filters.tdfilt"><code>DSP.Filters.tdfilt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tdfilt(h, x)</code></pre><p>Apply filter or filter coefficients <code>h</code> along the first dimension of array <code>x</code> using a naïve time-domain algorithm</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L433-L438">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.tdfilt!" href="#DSP.Filters.tdfilt!"><code>DSP.Filters.tdfilt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tdfilt!(out, h, x)</code></pre><p>Like <code>tdfilt</code>, but writes the result into array <code>out</code>. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/filt.jl#L443-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.resample" href="#DSP.Filters.resample"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resample(x, rate[, coef])</code></pre><p>Resample <code>x</code> at rational or arbitrary <code>rate</code>. <code>coef</code> is an optional vector of FIR filter taps. If <code>coef</code> is not provided, the taps will be computed using a Kaiser window.</p><p>Internally, <code>resample</code> uses a polyphase <code>FIRFilter</code> object, but performs additional operations to make resampling a signal easier. It compensates for for the <code>FIRFilter</code>&#39;s delay (ramp-up), and appends zeros to <code>x</code>. The result is that when the input and output signals are plotted on top of each other, they correlate very well, but one signal will have more samples that the other.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/stream_filt.jl#L682-L695">source</a></section><h2><a class="nav-anchor" id="Filter-design-1" href="#Filter-design-1">Filter design</a></h2><p>Most analog and digital filters are constructed by composing <a href="#response-types-1">response types</a>, which determine the frequency response of the filter, with <a href="#design-methods-1">design methods</a>, which determine how the filter is constructed. The response type is <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a>, <a href="#DSP.Filters.Highpass"><code>Highpass</code></a>, <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> or <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> and includes the edges of the bands. The design method is <a href="#DSP.Filters.Butterworth"><code>Butterworth</code></a>, <a href="#DSP.Filters.Chebyshev1"><code>Chebyshev1</code></a>, <a href="#DSP.Filters.Chebyshev2"><code>Chebyshev2</code></a>,  <a href="#DSP.Filters.Elliptic"><code>Elliptic</code></a>, or <a href="#DSP.Filters.FIRWindow"><code>FIRWindow</code></a>, and includes any necessary parameters for the method that affect the shape of the response, such as filter order, ripple, and attenuation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.analogfilter" href="#DSP.Filters.analogfilter"><code>DSP.Filters.analogfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">analogfilter(responsetype, designmethod)</code></pre><p>Construct an analog filter. See below for possible response and filter types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L415-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.digitalfilter" href="#DSP.Filters.digitalfilter"><code>DSP.Filters.digitalfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">digitalfilter(responsetype, designmethod)</code></pre><p>Construct a digital filter. See below for possible response and filter types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L455-L460">source</a></section><p>For some filters, the design method is more general or  inherently implies a response type; these <a href="#direct-design-methods-1">direct design methods</a> include <a href="#DSP.Filters.remez"><code>remez</code></a> which designs equiripple FIR filters of all types, and <a href="#DSP.Filters.iirnotch"><code>iirnotch</code></a> which designs a  2nd order &quot;biquad&quot; IIR notch filter.</p><h3><a class="nav-anchor" id="response-types-1" href="#response-types-1">Filter response types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Lowpass" href="#DSP.Filters.Lowpass"><code>DSP.Filters.Lowpass</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Lowpass(Wn[; fs])</code></pre><p>Low pass filter with cutoff frequency <code>Wn</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L249-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Highpass" href="#DSP.Filters.Highpass"><code>DSP.Filters.Highpass</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Highpass(Wn[; fs])</code></pre><p>High pass filter with cutoff frequency <code>Wn</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L262-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Bandpass" href="#DSP.Filters.Bandpass"><code>DSP.Filters.Bandpass</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Bandpass(Wn1, Wn2[; fs])</code></pre><p>Band pass filter with normalized pass band (<code>Wn1</code>, <code>Wn2</code>). If <code>fs</code> is not specified, <code>Wn1</code> and <code>Wn2</code> are interpreted as normalized frequencies in half-cycles/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L276-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Bandstop" href="#DSP.Filters.Bandstop"><code>DSP.Filters.Bandstop</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Bandstop(Wn1, Wn2[; fs])</code></pre><p>Band stop filter with normalized stop band (<code>Wn1</code>, <code>Wn2</code>). If <code>fs</code> is not specified, <code>Wn1</code> and <code>Wn2</code> are interpreted as normalized frequencies in half-cycles/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L293-L299">source</a></section><h3><a class="nav-anchor" id="design-methods-1" href="#design-methods-1">Filter design methods</a></h3><h4><a class="nav-anchor" id="IIR-filter-design-methods-1" href="#IIR-filter-design-methods-1">IIR filter design methods</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Butterworth" href="#DSP.Filters.Butterworth"><code>DSP.Filters.Butterworth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Butterworth(n)</code></pre><p><span>$n$</span> pole Butterworth filter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Chebyshev1" href="#DSP.Filters.Chebyshev1"><code>DSP.Filters.Chebyshev1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Chebyshev1(n, ripple)</code></pre><p><code>n</code> pole Chebyshev type I filter with <code>ripple</code> dB ripple in the passband.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L75-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Chebyshev2" href="#DSP.Filters.Chebyshev2"><code>DSP.Filters.Chebyshev2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Chebyshev2(n, ripple)</code></pre><p><code>n</code> pole Chebyshev type II filter with <code>ripple</code> dB ripple in the stopband.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L107-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.Elliptic" href="#DSP.Filters.Elliptic"><code>DSP.Filters.Elliptic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Elliptic(n, rp, rs)</code></pre><p><code>n</code> pole elliptic (Cauer) filter with <code>rp</code> dB ripple in the passband and <code>rs</code> dB attentuation in the stopband.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L225-L230">source</a></section><h4><a class="nav-anchor" id="FIR-filter-design-methods-1" href="#FIR-filter-design-methods-1">FIR filter design methods</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.FIRWindow" href="#DSP.Filters.FIRWindow"><code>DSP.Filters.FIRWindow</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FIRWindow(window; scale=true)</code></pre><p>FIR filter design using window <code>window</code>, a vector whose length matches the number of taps in the resulting filter.</p><p>If <code>scale</code> is <code>true</code> (default), the designed FIR filter is scaled so that the following holds:</p><ul><li>For <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a> and <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> filters, the frequency response is unity at 0 (DC).</li><li>For <a href="#DSP.Filters.Highpass"><code>Highpass</code></a> filters, the frequency response is unity at the Nyquist frequency.</li><li>For <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> filters, the frequency response is unity in the center of the passband.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L515-L530">source</a><div><div><pre><code class="language-none">FIRWindow(; transitionwidth, attenuation=60, scale=true)</code></pre><p>Kaiser window FIR filter design. The required number of taps is calculated based on <code>transitionwidth</code> (in half-cycles/sample) and stopband <code>attenuation</code> (in dB). <code>attenuation</code> defaults to 60 dB.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L534-L541">source</a></section><h3><a class="nav-anchor" id="direct-design-methods-1" href="#direct-design-methods-1">Direct filter design methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.remez" href="#DSP.Filters.remez"><code>DSP.Filters.remez</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remez(numtaps::Integer, band_defs;
      Hz::Real=1.0,
      neg::Bool=false,
      maxiter::Integer=25,
      grid_density::Integer=16)</code></pre><p>Calculate the minimax optimal filter using the Remez exchange algorithm <a href="#footnote-McClellan1973a">[McClellan1973a]</a> <a href="#footnote-McClellan1973b">[McClellan1973b]</a>.</p><p>This is the simplified API that accepts just 2 required arguments (numtaps, band_defs). For a scipy compatible version see the 3 arguments version (numtaps, bands, desired). </p><p>Calculate the filter-coefficients for the finite impulse response (FIR) filter whose transfer function minimizes the maximum error between the desired gain and the realized gain in the specified frequency bands using the Remez exchange algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>numtaps::Integer</code>: The desired number of taps in the filter.    The number of taps is the number of terms in the filter, or the filter    order plus one.</li><li><code>bands_defs</code>: A sequence of band definitions.   This sequence defines the bands. Each entry is a pair. The pair&#39;s   first item is a tuple of band edges (low, high). The pair&#39;s second item    defines the desired response and weight in that band. The weight is optional   and defaults to 1.0. Both the desired response and weight may be either scalars   or functions. If a function, the function should accept a real frequency and   return the real desired response or real weight. Examples:<ul><li>LPF with unity weights. <code>[(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]</code></li><li>LPF with weight of 2 in the stop band. <code>[(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]</code></li><li>BPF with unity weights. <code>[(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]</code></li><li>Hilbert transformer. <code>[(0.1, 0.95) =&gt; 1]; neg=true</code></li><li>Differentiator. <code>[(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true</code></li></ul></li><li><code>Hz::Real</code>: The sampling frequency in Hz. Default is 1.</li><li><code>neg::Bool</code>: Whether the filter has negative symmetry or not. Default is false.   If false, the filter is even-symmetric. If true, the filter is odd-symmetric.   neg=true means that h[n]=-h[end+1-n]; neg=false means that h[n]=h[end+1-n].</li><li><code>maxiter::Integer</code>: (optional)   Maximum number of iterations of the algorithm. Default is 25.</li><li><code>grid_density:Integer</code>: (optional)   Grid density. The dense grid used in <code>remez</code> is of size   <code>(numtaps + 1) * grid_density</code>. Default is 16.</li></ul><p><strong>Returns</strong></p><ul><li><code>h::Array{Float64,1}</code>: A rank-1 array containing the coefficients of the optimal   (in a minimax sense) filter.</li></ul><div class="footnote" id="footnote-McClellan1973a"><a href="#footnote-McClellan1973a"><strong>[McClellan1973a]</strong></a></div><p>J. H. McClellan and T. W. Parks, A unified approach to the design of optimum FIR linear phase digital filters, IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.</p><div class="footnote" id="footnote-McClellan1973b"><a href="#footnote-McClellan1973b"><strong>[McClellan1973b]</strong></a></div><p>J. H. McClellan, T. W. Parks and L. R. Rabiner, A Computer Program for Designing Optimum FIR Linear Phase Digital Filters, IEEE Trans. Audio Electroacoust., vol. AU-21, pp. 506-525, 1973.</p><p><strong>Examples</strong></p><p>Construct a length 35 filter with a passband at 0.15-0.4 Hz  (desired response of 1), and stop bands at 0-0.1 Hz and 0.45-0.5 Hz (desired response of 0). Note: the behavior in the frequency ranges between  those bands - the transition bands - is unspecified.</p><pre><code class="language-julia-repl">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);</code></pre><p>You can trade-off maximum error achieved for transition bandwidth.  The wider the transition bands, the lower the maximum error in the bands specified. Here is a bandpass filter with the same passband, but wider transition bands.</p><pre><code class="language-julia-repl">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);</code></pre><p>Here we compute the frequency responses and plot them in dB.</p><pre><code class="language-julia-repl">julia&gt; using PyPlot
julia&gt; b = DSP.Filters.PolynomialRatio(bpass, [1.0])
julia&gt; b2 = DSP.Filters.PolynomialRatio(bpass2, [1.0])
julia&gt; f = range(0, stop=0.5, length=1000)
julia&gt; plot(f, 20*log10.(abs.(freqz(b,f,1.0))))
julia&gt; plot(f, 20*log10.(abs.(freqz(b2,f,1.0))))
julia&gt; grid()</code></pre><p><strong>Examples from the unittests - standard (even) symmetry.</strong></p><p>Length 151 LPF (Low Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(151, [(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]; Hz=2.0);</code></pre><p>Length 152 LPF. Non-default &quot;weight&quot; input.</p><pre><code class="language-julia-repl">julia&gt; h = remez(152, [(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]; Hz=2.0);</code></pre><p>Length 51 HPF (High Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(51, [(0, 0.75) =&gt; 0, (0.8, 1.0) =&gt; 1]; Hz=2.0);</code></pre><p>Length 180 BPF (Band Pass Filter).</p><pre><code class="language-julia-repl">julia&gt; h = remez(180, [(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]; Hz=2.0, maxiter=30);</code></pre><p><strong>Examples from the unittests - Odd-symmetric filters - hilbert and differentiators type.</strong></p><p>Even length - has a much better approximation since the response is not constrained to 0 at the nyquist frequency.  Length 20 Hilbert transformer.</p><pre><code class="language-julia-repl">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 21 Hilbert transformer.</p><pre><code class="language-julia-repl">julia&gt; h = remez(21, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 200 differentiator.</p><pre><code class="language-julia-repl">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Length 201 differentiator.</p><pre><code class="language-julia-repl">julia&gt; h = remez(201, [(0.05, 0.95) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Inverse sinc filter - custom response function</p><pre><code class="language-julia-repl">julia&gt; L = 64; Fs = 4800*L;
julia&gt; passband_response_function = f -&gt; (f==0) ? 1.0 : abs.((π*f/4800) ./ sin.(π*f/4800));
julia&gt; h = remez(201, [(    0.0, 2880.0) =&gt; (passband_response_function, 1.0),
                (10000.0,   Fs/2) =&gt; (0.0, 100.0)]; Hz=Fs);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/remez_fir.jl#L256-L396">source</a><div><div><pre><code class="language-none">remez(numtaps::Integer, 
      bands::Vector, 
      desired::Vector; 
      weight::Vector=[], 
      Hz::Real=1.0, 
      filter_type::RemezFilterType=filter_type_bandpass,
      maxiter::Integer=25, 
      grid_density::Integer=16)</code></pre><p>This is the scipy compatible version that requires 3 arguments (numtaps, bands, desired).  For a simplified API, see the 2 argument version (numtaps, band_defs). The filters designed are equivalent, the inputs are just specified in a different way. Below the arguments and examples are described that differ from the simplified API version.</p><p><strong>Arguments</strong></p><ul><li><code>bands::Vector</code>: A monotonic sequence containing the band edges in Hz.   All elements must be non-negative and less than half the sampling   frequency as given by <code>Hz</code>.</li><li><code>desired::Vector</code>:A sequence half the size of bands containing the desired    gain in each of the specified bands.</li><li><code>weight::Vector</code>: (optional)   A relative weighting to give to each band region. The length of   <code>weight</code> has to be half the length of <code>bands</code>.</li><li><code>filter_type::RemezFilterType</code>: Default is <code>filter_type_bandpass</code>.   The type of filter:<ul><li><code>filter_type_bandpass</code> : flat response in bands. This is the default.</li><li><code>filter_type_differentiator</code> : frequency proportional response in bands.   Odd symetric as in <code>filter_type_hilbert</code> case, but with a linear sloping   desired response.</li><li><code>filter_type_hilbert</code> : filter with odd symmetry, that is, type III             (for even order) or type IV (for odd order)             linear phase filters.</li></ul></li></ul><p><strong>Examples</strong></p><p>Compare the examples with the simplified API and the Scipy API. Each of the following blocks first designs a filter using the  simplified (recommended) API, and then designs the same filter using the Scipy-compatible API.</p><pre><code class="language-julia-repl">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);

julia&gt; bpass = remez(35, [0, 0.1, 0.15, 0.4, 0.45, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);

julia&gt; bpass2 = remez(35, [0, 0.08, 0.15, 0.4, 0.47, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);

julia&gt; h = remez(20, [0.1, 0.95], [1]; filter_type=filter_type_hilbert, Hz=2.0);
</code></pre><pre><code class="language-julia-repl">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);

julia&gt; h = remez(200, [0.01, 0.99], [1]; filter_type=filter_type_differentiator, Hz=2.0);
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/remez_fir.jl#L771-L839">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.iirnotch" href="#DSP.Filters.iirnotch"><code>DSP.Filters.iirnotch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">iirnotch(Wn, bandwidth[; fs])</code></pre><p>Second-order digital IIR notch filter <a href="#footnote-Orfandis">[Orfandis]</a> at frequency <code>Wn</code> with bandwidth <code>bandwidth</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p><div class="footnote" id="footnote-Orfandis"><a href="#footnote-Orfandis"><strong>[Orfandis]</strong></a></div><p>Orfanidis, S. J. (1996). Introduction to signal processing. Englewood Cliffs, N.J: Prentice Hall, p. 370.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/design.jl#L468-L478">source</a></section><h2><a class="nav-anchor" id="Filter-response-1" href="#Filter-response-1">Filter response</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.freqz" href="#DSP.Filters.freqz"><code>DSP.Filters.freqz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">freqz(filter, w = range(0, stop=π, length=250))</code></pre><p>Frequency response of a digital <code>filter</code> at normalised frequency or frequencies <code>w</code> in radians/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L28-L33">source</a><div><div><pre><code class="language-none">freqz(filter, hz, fs)</code></pre><p>Frequency response of a digital <code>filter</code> at frequency or frequencies <code>hz</code> with sampling rate <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L38-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.phasez" href="#DSP.Filters.phasez"><code>DSP.Filters.phasez</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">phasez(filter, w = range(0, stop=π, length=250))</code></pre><p>Phase response of a digital <code>filter</code> at normalised frequency or frequencies <code>w</code> in radians/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L49-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.impz" href="#DSP.Filters.impz"><code>DSP.Filters.impz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">impz(filter, n=100)</code></pre><p>Impulse response of a digital <code>filter</code> with <code>n</code> points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.stepz" href="#DSP.Filters.stepz"><code>DSP.Filters.stepz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stepz(filter, n=100)</code></pre><p>Step response of a digital <code>filter</code> with <code>n</code> points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L71-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.freqs" href="#DSP.Filters.freqs"><code>DSP.Filters.freqs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">freqs(filter, w)</code></pre><p>Frequency response of an analog <code>filter</code> at normalised frequency or frequencies <code>w</code> in radians/sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L82-L87">source</a><div><div><pre><code class="language-none">freqs(filter, hz, fs)</code></pre><p>Frequency response of an analog <code>filter</code> at frequency or frequencies <code>hz</code> with sampling rate <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/response.jl#L113-L118">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.coefb" href="#DSP.Filters.coefb"><code>DSP.Filters.coefb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coefb(f)</code></pre><p>Coefficients of the numerator of a PolynomialRatio object, highest power first, i.e., the <code>b</code> passed to <code>filt()</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L105-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.coefa" href="#DSP.Filters.coefa"><code>DSP.Filters.coefa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coefa(f)</code></pre><p>Coefficients of the denominator of a PolynomialRatio object, highest power first, i.e., the <code>a</code> passed to <code>filt()</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/e004b8001c51f3e054d180df55572b683436a619/src/Filters/coefficients.jl#L114-L119">source</a></section><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>Construct a 4th order elliptic lowpass filter with normalized cutoff frequency 0.2, 0.5 dB of passband ripple, and 30 dB attentuation in the stopband and extract the coefficients of the numerator and denominator of the transfer function:</p><pre><code class="language-julia">responsetype = Lowpass(0.2)
designmethod = Elliptic(4, 0.5, 30)
tf = convert(PolynomialRatio, digitalfilter(responsetype, designmethod))
numerator_coefs = coefb(tf)
denominator_coefs = coefa(tf)</code></pre><p>Filter the data in <code>x</code>, sampled at 1000 Hz, with a 4th order Butterworth bandpass filter between 10 and 40 Hz:</p><pre><code class="language-julia">responsetype = Bandpass(10, 40; fs=1000)
designmethod = Butterworth(4)
filt(digitalfilter(responsetype, designmethod), x)</code></pre><p>Filter the data in <code>x</code>, sampled at 50 Hz, with a 64 tap Hanning window FIR lowpass filter at 5 Hz:</p><pre><code class="language-julia">responsetype = Lowpass(5; fs=50)
designmethod = FIRWindow(hanning(64))
filt(digitalfilter(responsetype, designmethod), x)</code></pre><footer><hr/><a class="previous" href="../windows/"><span class="direction">Previous</span><span class="title"><code>Windows</code> - window functions</span></a><a class="next" href="../util/"><span class="direction">Next</span><span class="title"><code>Util</code> - utility functions</span></a></footer></article></body></html>
