<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Filters - filter design and filtering · DSP.jl</title><meta name="title" content="Filters - filter design and filtering · DSP.jl"/><meta property="og:title" content="Filters - filter design and filtering · DSP.jl"/><meta property="twitter:title" content="Filters - filter design and filtering · DSP.jl"/><meta name="description" content="Documentation for DSP.jl."/><meta property="og:description" content="Documentation for DSP.jl."/><meta property="twitter:description" content="Documentation for DSP.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DSP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Submodules</span><ul><li><a class="tocitem" href="../periodograms/"><code>Periodograms</code> - periodogram estimation</a></li><li><a class="tocitem" href="../estimation/"><code>Estimation</code> - parametric estimation functions</a></li><li><a class="tocitem" href="../windows/"><code>Windows</code> - window functions</a></li><li class="is-active"><a class="tocitem" href><code>Filters</code> - filter design and filtering</a><ul class="internal"><li><a class="tocitem" href="#coefficient-objects"><span>Filter coefficient objects</span></a></li><li><a class="tocitem" href="#stateful-filter-objects"><span>Stateful filter objects</span></a></li><li><a class="tocitem" href="#Filter-application"><span>Filter application</span></a></li><li><a class="tocitem" href="#Filter-design"><span>Filter design</span></a></li><li><a class="tocitem" href="#Filter-response"><span>Filter response</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../util/"><code>Util</code> - utility functions</a></li><li><a class="tocitem" href="../convolutions/"><code>Convolutions</code> - similarity methods</a></li><li><a class="tocitem" href="../lpc/"><code>LPC</code> - Linear Predictive Coding</a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../appendix/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Submodules</a></li><li class="is-active"><a href><code>Filters</code> - filter design and filtering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>Filters</code> - filter design and filtering</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDSP/DSP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDSP/DSP.jl/blob/master/docs/src/filters.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Filters-filter-design-and-filtering"><a class="docs-heading-anchor" href="#Filters-filter-design-and-filtering"><code>Filters</code> - filter design and filtering</a><a id="Filters-filter-design-and-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filters-filter-design-and-filtering" title="Permalink"></a></h1><p>DSP.jl differentiates between <a href="#coefficient-objects">filter coefficients</a> and <a href="#stateful-filter-objects">stateful filters</a>. Filter coefficient objects specify the response of the filter in one of several standard forms. Stateful filter objects carry the state of the filter together with filter coefficients in an implementable form (<code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>). When invoked on a filter coefficient object, <code>filt</code> does not preserve state.</p><h2 id="coefficient-objects"><a class="docs-heading-anchor" href="#coefficient-objects">Filter coefficient objects</a><a id="coefficient-objects-1"></a><a class="docs-heading-anchor-permalink" href="#coefficient-objects" title="Permalink"></a></h2><p>DSP.jl supports common filter representations. Filter coefficients can be converted from one type to another using <code>convert</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.ZeroPoleGain" href="#DSP.Filters.ZeroPoleGain"><code>DSP.Filters.ZeroPoleGain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroPoleGain(z::Vector, p::Vector, k::Number)</code></pre><p>Filter representation in terms of zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code>:</p><p class="math-container">\[H(x) = k\frac{(x - \verb!z[1]!) \ldots (x - \verb!z[m]!)}{(x - \verb!p[1]!) \ldots (x - \verb!p[n]!)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.PolynomialRatio" href="#DSP.Filters.PolynomialRatio"><code>DSP.Filters.PolynomialRatio</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolynomialRatio(b::Union{Number, Vector{&lt;:Number}}, a::Union{Number, Vector{&lt;:Number}})</code></pre><p>Filter representation in terms of the coefficients of the numerator <code>b</code> and denominator <code>a</code> in the z or s domain where <code>b</code> and <code>a</code> are vectors ordered from highest power to lowest.</p><p>Inputs that are <code>Number</code>s are treated as one-element <code>Vector</code>s.</p><p>Filter with:</p><ul><li>Transfer function in z domain (zero &amp; negative z powers):</li></ul><p class="math-container">\[H(z) = \frac{\verb!b[1]! + \ldots + \verb!b[m]! z^{-m+1}}{\verb!a[1]! + \ldots + \verb!a[n]! z^{-n+1}}\]</p><p>returns <code>PolynomialRatio</code> object with <code>a[1] = 1</code> and other specified coefficients divided by <code>a[1]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; PolynomialRatio([1,1],[1,2])
PolynomialRatio{:z, Float64}(LaurentPolynomial(1.0*z⁻¹ + 1.0), LaurentPolynomial(2.0*z⁻¹ + 1.0))
julia&gt; PolynomialRatio{:z}([1,2,3],[2,3,4])
PolynomialRatio{:z, Float64}(LaurentPolynomial(1.5*z⁻² + 1.0*z⁻¹ + 0.5), LaurentPolynomial(2.0*z⁻² + 1.5*z⁻¹ + 1.0))</code></pre><ul><li>Transfer function in s domain (zero &amp; positive s powers):</li></ul><p class="math-container">\[H(s) = \frac{\verb!b[1]! s^{m-1} + \ldots + \verb!b[m]!}{\verb!a[1]! s^{n-1} + \ldots + \verb!a[n]!}\]</p><p>returns <code>PolynomialRatio</code> object with specified <code>b</code> and <code>a</code> coefficients.</p><pre><code class="language-julia-repl hljs">julia&gt; PolynomialRatio{:s}([1,2,3],[2,3,4])
PolynomialRatio{:s, Int64}(LaurentPolynomial(3 + 2*s + s²), LaurentPolynomial(4 + 3*s + 2*s²))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L94-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Biquad" href="#DSP.Filters.Biquad"><code>DSP.Filters.Biquad</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Biquad(b0::T, b1::T, b2::T, a1::T, a2::T) where T &lt;: Number</code></pre><p>Filter representation in terms of the transfer function of a single second-order section given by:</p><p class="math-container">\[H(s) = \frac{\verb!b0! s^2+\verb!b1! s+\verb!b2!}{s^2+\verb!a1! s + \verb!a2!}\]</p><p>or equivalently:</p><p class="math-container">\[H(z) = \frac{\verb!b0!+\verb!b1! z^{-1}+\verb!b2! z^{-2}}{1+\verb!a1! z^{-1} + \verb!a2! z^{-2}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L221-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.SecondOrderSections" href="#DSP.Filters.SecondOrderSections"><code>DSP.Filters.SecondOrderSections</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SecondOrderSections(biquads::Vector{&lt;:Biquad}, gain::Number)</code></pre><p>Filter representation in terms of a cascade of second-order sections and gain. <code>biquads</code> must be specified as a vector of <code>Biquads</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L287-L293">source</a></section></article><p>These filter coefficient objects support the following arithmetic operations: inversion (<code>inv</code>), multiplication (<code>*</code>) for series connection, and integral power (<code>^</code>) for repeated multiplication with itself. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; H = PolynomialRatio([1.0], [1.0, 0.3])
PolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.3*z⁻¹ + 1.0))

julia&gt; inv(H)
PolynomialRatio{:z, Float64}(LaurentPolynomial(0.3*z⁻¹ + 1.0), LaurentPolynomial(1.0))

julia&gt; H * H
PolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))

julia&gt; H^2
PolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))

julia&gt; H^-2
PolynomialRatio{:z, Float64}(LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0), LaurentPolynomial(1.0))
</code></pre><h2 id="stateful-filter-objects"><a class="docs-heading-anchor" href="#stateful-filter-objects">Stateful filter objects</a><a id="stateful-filter-objects-1"></a><a class="docs-heading-anchor-permalink" href="#stateful-filter-objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.DF2TFilter" href="#DSP.Filters.DF2TFilter"><code>DSP.Filters.DF2TFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DF2TFilter(coef::FilterCoefficients{:z}[, si])
DF2TFilter(coef::FilterCoefficients{:z}[, sitype::Type][, coldims::Tuple])</code></pre><p>Construct a stateful direct form II transposed filter with coefficients <code>coef</code>.</p><p>One can optionally specify as the second argument either</p><ul><li><code>si</code>, an array representing the initial filter state, or</li><li><code>sitype</code>, the eltype of a zeroed <code>si</code> and/or <code>coldims</code>, the size of extra dimensions of the input. E.g. to column-wise filter an input with dims <code>(L, N1, N2)</code>, set <code>coldims</code> to <code>(N1, N2)</code>.</li></ul><p>The initial filter state defaults to zeros if called with one argument.</p><p>If <code>coef</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>coef</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L121-L139">source</a></section></article><p>DSP.jl&#39;s <code>FIRFilter</code> type maintains state between calls to <a href="#DSP.filt"><code>filt</code></a>, allowing you to filter a signal of indefinite length in RAM-friendly chunks. <code>FIRFilter</code> contains nothing more that the state of the filter, and a <code>FIRKernel</code>. There are five different kinds of <code>FIRKernel</code> for single rate, up-sampling, down-sampling, rational resampling, and arbitrary sample-rate conversion. You need not specify the type of kernel. The <code>FIRFilter</code> constructor selects the correct kernel based on input parameters.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.FIRFilter" href="#DSP.Filters.FIRFilter"><code>DSP.Filters.FIRFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FIRFilter(h::Vector[, ratio::Union{Integer,Rational}])</code></pre><p>Construct a stateful FIRFilter object from the vector of filter taps <code>h</code>. <code>ratio</code> is an optional rational integer which specifies the input to output sample rate relationship (e.g. <code>147//160</code> for converting recorded audio from 48 KHz to 44.1 KHz).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/stream_filt.jl#L147-L154">source</a></section><section><div><pre><code class="language-julia hljs">FIRFilter(h::Vector, rate::AbstractFloat[, Nϕ::Integer=32])</code></pre><p>Returns a polyphase FIRFilter object from the vector of filter taps <code>h</code>. <code>rate</code> is a floating point number that specifies the input to output sample-rate relationship <span>$\frac{fs_{out}}{fs_{in}}$</span>. <code>Nϕ</code> is an optional parameter which specifies the number of <em>phases</em> created from <code>h</code>. <code>Nϕ</code> defaults to 32.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/stream_filt.jl#L180-L188">source</a></section></article><h2 id="Filter-application"><a class="docs-heading-anchor" href="#Filter-application">Filter application</a><a id="Filter-application-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-application" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.filt" href="#DSP.filt"><code>DSP.filt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filt(b::Union{AbstractVector,Number},
     a::Union{AbstractVector,Number},
     x::AbstractArray,
     [si::AbstractArray])</code></pre><p>Apply filter described by vectors <code>a</code> and <code>b</code> to vector <code>x</code>, with an optional initial filter state vector <code>si</code> (defaults to zeros).</p><p>Inputs that are <code>Number</code>s are treated as one-element <code>Vector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/dspbase.jl#L7-L17">source</a></section><section><div><pre><code class="language-julia hljs">filt(f::FilterCoefficients{:z}, x::AbstractArray[, si])</code></pre><p>Apply filter or filter coefficients <code>f</code> along the first dimension of array <code>x</code>. If <code>f</code> is a filter coefficient object, <code>si</code> is an optional array representing the initial filter state (defaults to zeros). If <code>f</code> is a <code>PolynomialRatio</code>, <code>Biquad</code>, or <code>SecondOrderSections</code>, filtering is implemented directly. If <code>f</code> is a <code>ZeroPoleGain</code> object, it is first converted to a <code>SecondOrderSections</code> object.  If <code>f</code> is a Vector, it is interpreted as an FIR filter, and a naïve or FFT-based algorithm is selected based on the data and filter length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L22-L34">source</a></section><section><div><pre><code class="language-julia hljs">filt(f::DF2TFilter{&lt;:FilterCoefficients{:z},&lt;:Array{T}}, x::AbstractArray{V}) where {T,V}</code></pre><p>Apply the <a href="#stateful-filter-objects">stateful filter</a> <code>f</code> on <code>x</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The output array has eltype <code>promote_type(T, V)</code>, where <code>T</code> is the eltype of the filter state.</p><p>For more control over the output type, provide a preallocated output array <code>out</code> to <code>filt!(out, f, x)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L237-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.filt!" href="#DSP.filt!"><code>DSP.filt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filt!(out, b, a, x, [si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt</code></a> but writes the result into the <code>out</code> argument, which may alias the input <code>x</code> to modify it in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/dspbase.jl#L26-L31">source</a></section><section><div><pre><code class="language-julia hljs">filt!(out, f, x[, si])</code></pre><p>Same as <a href="#DSP.filt"><code>filt()</code></a> but writes the result into the <code>out</code> argument. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.filtfilt" href="#DSP.Filters.filtfilt"><code>DSP.Filters.filtfilt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filtfilt(coef::FilterCoefficients, x::AbstractArray)
filtfilt(b::AbstractVector, x::AbstractArray)
filtfilt(b::AbstractVector, a::AbstractVector, x::AbstractArray)</code></pre><p>Filter <code>x</code> in the forward and reverse directions using either a <code>FilterCoefficients</code> object <code>coef</code>, or the coefficients <code>b</code> and optionally <code>a</code> as in <a href="#DSP.filt"><code>filt</code></a>. The initial state of the filter is computed so that its response to a step function is steady state. Before filtering, the data is extrapolated at both ends with an odd-symmetric extension of length <code>min(3*(max(length(b), length(a))-1), size(x, 1) - 1)</code>.</p><p>Because <code>filtfilt</code> applies the given filter twice, the effective filter order is twice the order of <code>coef</code>. The resulting signal has zero phase distortion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L307-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.fftfilt" href="#DSP.Filters.fftfilt"><code>DSP.Filters.fftfilt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fftfilt(h::AbstractVector{&lt;:Real}, x::AbstractArray{&lt;:Real})</code></pre><p>Apply FIR filter taps <code>h</code> along the first dimension of array <code>x</code> using an FFT-based overlap-save algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L477-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.fftfilt!" href="#DSP.Filters.fftfilt!"><code>DSP.Filters.fftfilt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fftfilt!(out::AbstractArray, h::AbstractVector, x::AbstractArray)</code></pre><p>Like <code>fftfilt</code> but writes result into out array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L488-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.tdfilt" href="#DSP.Filters.tdfilt"><code>DSP.Filters.tdfilt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tdfilt(h::AbstractVector, x::AbstractArray)</code></pre><p>Apply filter or filter coefficients <code>h</code> along the first dimension of array <code>x</code> using a naïve time-domain algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L450-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.tdfilt!" href="#DSP.Filters.tdfilt!"><code>DSP.Filters.tdfilt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tdfilt!(out::AbstractArray, h::AbstractVector, x::AbstractArray)</code></pre><p>Like <code>tdfilt</code>, but writes the result into array <code>out</code>. Output array <code>out</code> may not be an alias of <code>x</code>, i.e. filtering may not be done in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt.jl#L460-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.resample" href="#DSP.Filters.resample"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample(x::AbstractVector, rate::Real[, coef::Vector])</code></pre><p>Resample <code>x</code> at rational or arbitrary <code>rate</code>. <code>coef</code> is an optional vector of FIR filter taps. If <code>coef</code> is not provided, the taps will be computed using a Kaiser window.</p><p>Internally, <code>resample</code> uses a polyphase <code>FIRFilter</code> object, but performs additional operations to make resampling a signal easier. It compensates for the <code>FIRFilter</code>&#39;s delay (ramp-up), and appends zeros to <code>x</code>. The result is that when the input and output signals are plotted on top of each other, they correlate very well, but one signal will have more samples than the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/stream_filt.jl#L669-L682">source</a></section><section><div><pre><code class="language-julia hljs">resample(x::AbstractArray, rate::Real, h::Vector = resample_filter(rate); dims)</code></pre><p>Resample an array <code>x</code> along dimension <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/stream_filt.jl#L711-L715">source</a></section></article><h2 id="Filter-design"><a class="docs-heading-anchor" href="#Filter-design">Filter design</a><a id="Filter-design-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-design" title="Permalink"></a></h2><p>Most analog and digital filters are constructed by composing <a href="#response-types">response types</a>, which determine the frequency response of the filter, with <a href="#design-methods">design methods</a>, which determine how the filter is constructed.</p><p>The response type is <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a>, <a href="#DSP.Filters.Highpass"><code>Highpass</code></a>, <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> or <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> and includes the edges of the bands.</p><p>The design method is <a href="#DSP.Filters.Butterworth"><code>Butterworth</code></a>, <a href="#DSP.Filters.Chebyshev1"><code>Chebyshev1</code></a>, <a href="#DSP.Filters.Chebyshev2"><code>Chebyshev2</code></a>, <a href="#DSP.Filters.Elliptic"><code>Elliptic</code></a>, or <a href="#DSP.Filters.FIRWindow"><code>FIRWindow</code></a>, and includes any necessary parameters for the method that affect the shape of the response, such as filter order, ripple, and attenuation.</p><p><a href="#order-est-methods">Filter order estimation methods</a> are available in <a href="#DSP.Filters.buttord"><code>buttord</code></a>, <a href="#DSP.Filters.cheb1ord"><code>cheb1ord</code></a>, <a href="#DSP.Filters.cheb2ord"><code>cheb2ord</code></a>, and <a href="#DSP.Filters.ellipord"><code>ellipord</code></a> if the corner frequencies for different IIR filter types are known. <a href="#DSP.Filters.remezord"><code>remezord</code></a> can be used for an initial FIR filter order estimate.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.analogfilter" href="#DSP.Filters.analogfilter"><code>DSP.Filters.analogfilter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analogfilter(responsetype::FilterType, designmethod::FilterCoefficients)</code></pre><p>Construct an analog filter. See below for possible response and filter types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L427-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.digitalfilter" href="#DSP.Filters.digitalfilter"><code>DSP.Filters.digitalfilter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">digitalfilter(responsetype::FilterType, designmethod::FilterCoefficients[; fs::Real])</code></pre><p>Construct a digital filter. See below for possible response and filter types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L506-L511">source</a></section></article><p>For some filters, the design method is more general or inherently implies a response type; these <a href="#direct-design-methods">direct design methods</a> include <a href="#DSP.Filters.remez"><code>remez</code></a> which designs equiripple FIR filters of all types, and <a href="#DSP.Filters.iirnotch"><code>iirnotch</code></a> which designs a 2nd order &quot;biquad&quot; IIR notch filter.</p><p>For a more general application of creating a digital filter from s-domain representation of an analog filter, one can use <a href="#DSP.Filters.bilinear"><code>bilinear</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.bilinear" href="#DSP.Filters.bilinear"><code>DSP.Filters.bilinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilinear(f::FilterCoefficients{:s}, fs::Real)</code></pre><p>Calculate the digital filter (z-domain) ZPK representation of an analog filter defined in s-domain using bilinear transform with sampling frequency <code>fs</code>. The s-domain representation is first converted to a ZPK representation in s-domain and then transformed to z-domain using bilinear transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L437-L444">source</a></section><section><div><pre><code class="language-julia hljs">bilinear(f::ZeroPoleGain{:s,Z,P,K}, fs::Real) where {Z,P,K}</code></pre><p>Calculate the digital filter (z-domain) ZPK representation of an analog filter defined as a ZPK representation in s-domain using bilinear transform with sampling frequency <code>fs</code>.</p><p>Input s-domain representation must be a <code>ZeroPoleGain{:s, Z, P, K}</code> object:</p><p class="math-container">\[H(s) = f.k\frac{(s - \verb!f.z[1]!) \ldots (s - \verb!f.z[m]!)}{(s - \verb!f.p[1]!) \ldots (s - \verb!f.p[n]!)}\]</p><p>Output z-domain representation is a <code>ZeroPoleGain{:z, Z, P, K}</code> object:</p><p class="math-container">\[H(z) = K\frac{(z - \verb!Z[1]!) \ldots (z - \verb!Z[m]!)}{(z - \verb!P[1]!) \ldots (z - \verb!P[n]!)}\]</p><p>where <code>Z, P, K</code> are calculated as:</p><p class="math-container">\[Z[i] = \frac{(2 + \verb!f.z[i]!/\verb!fs!)}{(2 - \verb!f.z[i]!/\verb!fs!)} \quad \text{for } i = 1, \ldots, m\]</p><p class="math-container">\[P[i] = \frac{(2 + \verb!f.p[i]!/\verb!fs!)}{(2 - \verb!f.p[i]!/\verb!fs!)} \quad \text{for } i = 1, \ldots, n\]</p><p class="math-container">\[K = f.k \ \mathcal{Re} \left[ \frac{\prod_{i=1}^m (2*fs - f.z[i])}{\prod_{i=1}^n (2*fs - f.p[i])} \right]\]</p><p>Here, <code>m</code> and <code>n</code> are respectively the numbers of zeros and poles in the s-domain representation. If <code>m &lt; n</code>, then additional <code>n-m</code> zeros are added at <code>z = -1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L447-L474">source</a></section></article><h3 id="response-types"><a class="docs-heading-anchor" href="#response-types">Filter response types</a><a id="response-types-1"></a><a class="docs-heading-anchor-permalink" href="#response-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Lowpass" href="#DSP.Filters.Lowpass"><code>DSP.Filters.Lowpass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lowpass(Wn::Real)</code></pre><p>Low pass filter with cutoff frequency <code>Wn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Highpass" href="#DSP.Filters.Highpass"><code>DSP.Filters.Highpass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Highpass(Wn::Real)</code></pre><p>High pass filter with cutoff frequency <code>Wn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Bandpass" href="#DSP.Filters.Bandpass"><code>DSP.Filters.Bandpass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bandpass(Wn1::Real, Wn2::Real)</code></pre><p>Band pass filter with pass band frequencies (<code>Wn1</code>, <code>Wn2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.ComplexBandpass" href="#DSP.Filters.ComplexBandpass"><code>DSP.Filters.ComplexBandpass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComplexBandpass(Wn1, Wn2)</code></pre><p>Complex band pass filter with pass band frequencies (<code>Wn1</code>, <code>Wn2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Bandstop" href="#DSP.Filters.Bandstop"><code>DSP.Filters.Bandstop</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bandstop(Wn1::Real, Wn2::Real)</code></pre><p>Band stop filter with stop band frequencies (<code>Wn1</code>, <code>Wn2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L301-L305">source</a></section></article><p>The interpretation of the frequencies <code>Wn</code>, <code>Wn1</code> and <code>Wn2</code> depends on wether an analog or a digital filter is designed.</p><ol><li>If an analog filter is designed using <a href="#DSP.Filters.analogfilter"><code>analogfilter</code></a>, the frequencies are interpreted as analog frequencies in radians/second.</li><li>If a digital filter is designed using <a href="#DSP.Filters.digitalfilter"><code>digitalfilter</code></a> and the sampling frequency <code>fs</code> is specified, the frequencies of the filter response type are normalized to <code>fs</code>. This requires that the sampling frequency and the filter response type use the same frequency unit (Hz, radians/second, ...). If <code>fs</code> is not specified, the frequencies of the filter response type are interpreted as normalized frequencies in half-cycles/sample.</li></ol><h3 id="design-methods"><a class="docs-heading-anchor" href="#design-methods">Filter design methods</a><a id="design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#design-methods" title="Permalink"></a></h3><h4 id="IIR-filter-design-methods"><a class="docs-heading-anchor" href="#IIR-filter-design-methods">IIR filter design methods</a><a id="IIR-filter-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#IIR-filter-design-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Butterworth" href="#DSP.Filters.Butterworth"><code>DSP.Filters.Butterworth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Butterworth(n::Integer)</code></pre><p><span>$n$</span> pole Butterworth filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Chebyshev1" href="#DSP.Filters.Chebyshev1"><code>DSP.Filters.Chebyshev1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chebyshev1(n::Integer, ripple::Real)</code></pre><p><code>n</code> pole Chebyshev type I filter with <code>ripple</code> dB ripple in the passband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Chebyshev2" href="#DSP.Filters.Chebyshev2"><code>DSP.Filters.Chebyshev2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chebyshev2(n::Integer, ripple::Real)</code></pre><p><code>n</code> pole Chebyshev type II filter with <code>ripple</code> dB ripple in the stopband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.Elliptic" href="#DSP.Filters.Elliptic"><code>DSP.Filters.Elliptic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Elliptic(n::Integer, rp::Real, rs::Real)</code></pre><p><code>n</code> pole elliptic (Cauer) filter with <code>rp</code> dB ripple in the passband and <code>rs</code> dB attentuation in the stopband.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L222-L227">source</a></section></article><h3 id="order-est-methods"><a class="docs-heading-anchor" href="#order-est-methods">Filter order estimation methods</a><a id="order-est-methods-1"></a><a class="docs-heading-anchor-permalink" href="#order-est-methods" title="Permalink"></a></h3><h4 id="IIR-filter-order-estimation-methods"><a class="docs-heading-anchor" href="#IIR-filter-order-estimation-methods">IIR filter order estimation methods</a><a id="IIR-filter-order-estimation-methods-1"></a><a class="docs-heading-anchor-permalink" href="#IIR-filter-order-estimation-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.buttord" href="#DSP.Filters.buttord"><code>DSP.Filters.buttord</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(N, ωn) = buttord(Wp::Tuple{Real,Real}, Ws::Tuple{Real,Real}, Rp::Real, Rs::Real; domain=:z)</code></pre><p>Butterworth order estimate for bandpass and bandstop filter types. <code>Wp</code> and <code>Ws</code> are 2-element pass and stopband frequency edges, with no more than <code>Rp</code> dB passband ripple and at least <code>Rs</code> dB stopband attenuation. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. <code>N</code> is an integer indicating the lowest estimated filter order, with <code>ωn</code> specifying the cutoff or &quot;-3 dB&quot; frequencies.</p><p>If a domain of <code>:s</code> is specified, the passband and stopband frequencies are interpreted as radians/second, giving an order and natural frequencies for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L228-L240">source</a></section><section><div><pre><code class="language-julia hljs">(N, ωn) = buttord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain=:z)</code></pre><p>LPF/HPF Butterworth filter order and -3 dB frequency approximation. <code>Wp</code> and <code>Ws</code> are the passband and stopband frequencies, whereas <code>Rp</code> and <code>Rs</code> are the passband and stopband ripple attenuations in dB. If the passband is greater than stopband, the filter type is inferred to be for estimating the order of a highpass filter. <code>N</code> specifies the lowest possible integer filter order, whereas <code>ωn</code> is the cutoff or &quot;-3 dB&quot; frequency.</p><p>If a domain of <code>:s</code> is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L281-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.cheb1ord" href="#DSP.Filters.cheb1ord"><code>DSP.Filters.cheb1ord</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(N, ωn) = cheb1ord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Chebyshev Type I Filters. <code>Wp</code> and <code>Ws</code> indicate the passband and stopband frequency edges, and <code>Rp</code> and <code>Rs</code> indicate the maximum loss in the passband and the minimum attenuation in the stopband, (in dB.)</p><p>Based on the ordering of passband and stopband edges, the Lowpass or Highpass filter type is inferred. <code>N</code> indicates the smallest integer filter order that achieves the desired specifications, and <code>ωn</code> contains the natural frequency of the filter, (in this case, simply the passband edge.)</p><p>If a domain of <code>:s</code> is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L333-L348">source</a></section><section><div><pre><code class="language-julia hljs">(N, ωn) = cheb1ord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Chebyshev Type I Filters. <code>Wp</code> and <code>Ws</code> are 2-element frequency edges for Bandpass/Bandstop cases, with <code>Rp</code> and <code>Rs</code> representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. <code>N</code> is an integer indicating the lowest estimated filter order, with <code>ωn</code> specifying the cutoff or &quot;-3 dB&quot; frequencies. If a domain of <code>:s</code> is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L367-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.cheb2ord" href="#DSP.Filters.cheb2ord"><code>DSP.Filters.cheb2ord</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(N, ωn) = cheb2ord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Chebyshev Type II (inverse) Filters. <code>Wp</code> and <code>Ws</code> are the frequency edges for Bandpass/Bandstop cases, with <code>Rp</code> and <code>Rs</code> representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB.</p><p>Based on the ordering of the passband and stopband edges, the Lowpass or Highpass filter type is inferred. <code>N</code> is an integer indicating the lowest estimated filter order, with <code>ωn</code> specifying the &quot;-3 dB&quot; cutoff frequency.</p><p>If a domain of <code>:s</code> is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L400-L413">source</a></section><section><div><pre><code class="language-julia hljs">(N, ωn) = cheb2ord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Chebyshev Type II (inverse) Filters. <code>Wp</code> and <code>Ws</code> are 2-element frequency edges for Bandpass/Bandstop cases, with <code>Rp</code> and <code>Rs</code> representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB.</p><p>Based on the ordering of the passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. <code>N</code> is an integer indicating the lowest estimated filter order, with <code>ωn</code> specifying the &quot;-3 dB&quot; cutoff frequency.</p><p>If a domain of <code>:s</code> is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L428-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.ellipord" href="#DSP.Filters.ellipord"><code>DSP.Filters.ellipord</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(N, ωn) = ellipord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Elliptic (Cauer) Filters. <code>Wp</code> and <code>Ws</code> indicate the passband and stopband frequency edges, and <code>Rp</code> and <code>Rs</code> indicate the maximum loss in the passband and the minimum attenuation in the stopband, (in dB.)</p><p>Based on the ordering of passband and stopband edges, the Lowpass or Highpass filter type is inferred. <code>N</code> indicates the smallest integer filter order that achieves the desired specifications, and <code>ωn</code> contains the natural frequency of the filter, (in this case, simply the passband edge.)</p><p>If a domain of <code>:s</code> is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L333-L348">source</a></section><section><div><pre><code class="language-julia hljs">(N, ωn) = ellipord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)</code></pre><p>Integer and natural frequency order estimation for Elliptic (Cauer) Filters. <code>Wp</code> and <code>Ws</code> are 2-element frequency edges for Bandpass/Bandstop cases, with <code>Rp</code> and <code>Rs</code> representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. <code>N</code> is an integer indicating the lowest estimated filter order, with <code>ωn</code> specifying the cutoff or &quot;-3 dB&quot; frequencies. If a domain of <code>:s</code> is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is <code>:z</code>, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L367-L380">source</a></section></article><h4 id="FIR-filter-order-estimation-methods"><a class="docs-heading-anchor" href="#FIR-filter-order-estimation-methods">FIR filter order estimation methods</a><a id="FIR-filter-order-estimation-methods-1"></a><a class="docs-heading-anchor-permalink" href="#FIR-filter-order-estimation-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.remezord" href="#DSP.Filters.remezord"><code>DSP.Filters.remezord</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">N = remezord(Wp::Real, Ws::Real, Rp::Real, Rs::Real)</code></pre><p>Order estimation for lowpass digital filter cases based on the equations and coefficients in <sup class="footnote-reference"><a id="citeref-Rabiner" href="#footnote-Rabiner">[Rabiner]</a></sup>. The original equation returned the minimum filter length, whereas this implementation returns the order (N=L-1). <code>Wp</code> and <code>Ws</code> are the normalized passband and stopband frequencies, with <code>Rp</code> indicating the passband ripple and <code>Rs</code> is the stopband attenuation (linear.)</p><p>NOTE: The value of N is an initial approximation. If under-estimated, the order should be increased until the design specifications are met.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/filt_order.jl#L473-L489">source</a></section></article><h4 id="FIR-filter-design-methods"><a class="docs-heading-anchor" href="#FIR-filter-design-methods">FIR filter design methods</a><a id="FIR-filter-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#FIR-filter-design-methods" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.FIRWindow" href="#DSP.Filters.FIRWindow"><code>DSP.Filters.FIRWindow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FIRWindow(window::Vector; scale=true)</code></pre><p>FIR filter design using window <code>window</code>, a vector whose length matches the number of taps in the resulting filter.</p><p>If <code>scale</code> is <code>true</code> (default), the designed FIR filter is scaled so that the following holds:</p><ul><li>For <a href="#DSP.Filters.Lowpass"><code>Lowpass</code></a> and <a href="#DSP.Filters.Bandstop"><code>Bandstop</code></a> filters, the frequency response is unity at 0 (DC).</li><li>For <a href="#DSP.Filters.Highpass"><code>Highpass</code></a> filters, the frequency response is unity at the Nyquist frequency.</li><li>For <a href="#DSP.Filters.Bandpass"><code>Bandpass</code></a> filters, the frequency response is unity in the center of the passband.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L565-L580">source</a></section><section><div><pre><code class="language-julia hljs">FIRWindow(; transitionwidth::Real, attenuation::Real=60, scale::Bool=true)</code></pre><p>Kaiser window FIR filter design. The required number of taps is calculated based on <code>transitionwidth</code> (in half-cycles/sample) and stopband <code>attenuation</code> (in dB). <code>attenuation</code> defaults to 60 dB.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L584-L591">source</a></section></article><h3 id="direct-design-methods"><a class="docs-heading-anchor" href="#direct-design-methods">Direct filter design methods</a><a id="direct-design-methods-1"></a><a class="docs-heading-anchor-permalink" href="#direct-design-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.remez" href="#DSP.Filters.remez"><code>DSP.Filters.remez</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remez(numtaps::Integer, band_defs;
      Hz::Real=1.0,
      neg::Bool=false,
      maxiter::Integer=25,
      grid_density::Integer=16)</code></pre><p>Calculate the minimax optimal filter using the Remez exchange algorithm <sup class="footnote-reference"><a id="citeref-McClellan1973a" href="#footnote-McClellan1973a">[McClellan1973a]</a></sup> <sup class="footnote-reference"><a id="citeref-McClellan1973b" href="#footnote-McClellan1973b">[McClellan1973b]</a></sup>.</p><p>This is the simplified API that accepts just 2 required arguments (numtaps, band_defs). For a scipy compatible version see the 3 arguments version (numtaps, bands, desired).</p><p>Calculate the filter-coefficients for the finite impulse response (FIR) filter whose transfer function minimizes the maximum error between the desired gain and the realized gain in the specified frequency bands using the Remez exchange algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>numtaps::Integer</code>: The desired number of taps in the filter.   The number of taps is the number of terms in the filter, or the filter   order plus one.</li><li><code>band_defs</code>: A sequence of band definitions.   This sequence defines the bands. Each entry is a pair. The pair&#39;s   first item is a tuple of band edges (low, high). The pair&#39;s second item   defines the desired response and weight in that band. The weight is optional   and defaults to 1.0. Both the desired response and weight may be either scalars   or functions. If a function, the function should accept a real frequency and   return the real desired response or real weight. Examples:<ul><li>LPF with unity weights. <code>[(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]</code></li><li>LPF with weight of 2 in the stop band. <code>[(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]</code></li><li>BPF with unity weights. <code>[(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]</code></li><li>Hilbert transformer. <code>[(0.1, 0.95) =&gt; 1]; neg=true</code></li><li>Differentiator. <code>[(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true</code></li></ul></li><li><code>Hz::Real</code>: The sampling frequency in Hz. Default is 1.</li><li><code>neg::Bool</code>: Whether the filter has negative symmetry or not. Default is false.   If false, the filter is even-symmetric. If true, the filter is odd-symmetric.   neg=true means that h[n]=-h[end+1-n]; neg=false means that h[n]=h[end+1-n].</li><li><code>maxiter::Integer</code>: (optional)   Maximum number of iterations of the algorithm. Default is 25.</li><li><code>grid_density:Integer</code>: (optional)   Grid density. The dense grid used in <code>remez</code> is of size   <code>(numtaps + 1) * grid_density</code>. Default is 16.</li></ul><p><strong>Returns</strong></p><ul><li><code>h::Array{Float64,1}</code>: A rank-1 array containing the coefficients of the optimal   (in a minimax sense) filter.</li></ul><p><strong>Examples</strong></p><p>Construct a length 35 filter with a passband at 0.15-0.4 Hz (desired response of 1), and stop bands at 0-0.1 Hz and 0.45-0.5 Hz (desired response of 0). Note: the behavior in the frequency ranges between those bands - the transition bands - is unspecified.</p><pre><code class="language-julia-repl hljs">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);</code></pre><p>You can trade-off maximum error achieved for transition bandwidth. The wider the transition bands, the lower the maximum error in the bands specified. Here is a bandpass filter with the same passband, but wider transition bands.</p><pre><code class="language-julia-repl hljs">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);</code></pre><p>Here we compute the frequency responses and plot them in dB.</p><pre><code class="language-julia-repl hljs">julia&gt; using PyPlot
julia&gt; b = PolynomialRatio(bpass, [1.0])
julia&gt; b2 = PolynomialRatio(bpass2, [1.0])
julia&gt; f = range(0, stop=0.5, length=1000)
julia&gt; plot(f, 20*log10.(abs.(freqresp(b,f,1.0))))
julia&gt; plot(f, 20*log10.(abs.(freqresp(b2,f,1.0))))
julia&gt; grid()</code></pre><p><strong>Examples from the unittests - standard (even) symmetry.</strong></p><p>Length 151 LPF (Low Pass Filter).</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(151, [(0, 0.475) =&gt; 1, (0.5, 1.0) =&gt; 0]; Hz=2.0);</code></pre><p>Length 152 LPF. Non-default &quot;weight&quot; input.</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(152, [(0, 0.475) =&gt; (1, 1), (0.5, 1.0) =&gt; (0, 2)]; Hz=2.0);</code></pre><p>Length 51 HPF (High Pass Filter).</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(51, [(0, 0.75) =&gt; 0, (0.8, 1.0) =&gt; 1]; Hz=2.0);</code></pre><p>Length 180 BPF (Band Pass Filter).</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(180, [(0, 0.375) =&gt; 0, (0.4, 0.5) =&gt; 1, (0.525, 1.0) =&gt; 0]; Hz=2.0, maxiter=30);</code></pre><p><strong>Examples from the unittests - Odd-symmetric filters - hilbert and differentiators type.</strong></p><p>Even length - has a much better approximation since the response is not constrained to 0 at the nyquist frequency.  Length 20 Hilbert transformer.</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 21 Hilbert transformer.</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(21, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);</code></pre><p>Length 200 differentiator.</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Length 201 differentiator.</p><pre><code class="language-julia-repl hljs">julia&gt; h = remez(201, [(0.05, 0.95) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);</code></pre><p>Inverse sinc filter - custom response function</p><pre><code class="language-julia-repl hljs">julia&gt; L = 64; Fs = 4800*L;
julia&gt; passband_response_function = f -&gt; (f==0) ? 1.0 : abs.((π*f/4800) ./ sin.(π*f/4800));
julia&gt; h = remez(201, [(    0.0, 2880.0) =&gt; (passband_response_function, 1.0),
                (10000.0,   Fs/2) =&gt; (0.0, 100.0)]; Hz=Fs);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/remez_fir.jl#L258-L395">source</a></section><section><div><pre><code class="language-julia hljs">remez(numtaps::Integer,
      bands::Vector,
      desired::Vector;
      weight::Vector=[],
      Hz::Real=1.0,
      filter_type::RemezFilterType=filter_type_bandpass,
      maxiter::Integer=25,
      grid_density::Integer=16)</code></pre><p>This is the scipy compatible version that requires 3 arguments (numtaps, bands, desired). For a simplified API, see the 2 argument version (numtaps, band_defs). The filters designed are equivalent, the inputs are just specified in a different way. Below the arguments and examples are described that differ from the simplified API version.</p><p><strong>Arguments</strong></p><ul><li><code>bands::Vector</code>: A monotonic sequence containing the band edges in Hz.   All elements must be non-negative and less than half the sampling   frequency as given by <code>Hz</code>.</li><li><code>desired::Vector</code>:A sequence half the size of bands containing the desired   gain in each of the specified bands.</li><li><code>weight::Vector</code>: (optional)   A relative weighting to give to each band region. The length of   <code>weight</code> has to be half the length of <code>bands</code>.</li><li><code>filter_type::RemezFilterType</code>: Default is <code>filter_type_bandpass</code>.   The type of filter:<ul><li><code>filter_type_bandpass</code> : flat response in bands. This is the default.</li><li><code>filter_type_differentiator</code> : frequency proportional response in bands.   Odd symetric as in <code>filter_type_hilbert</code> case, but with a linear sloping   desired response.</li><li><code>filter_type_hilbert</code> : filter with odd symmetry, that is, type III             (for even order) or type IV (for odd order)             linear phase filters.</li></ul></li></ul><p><strong>Examples</strong></p><p>Compare the examples with the simplified API and the Scipy API. Each of the following blocks first designs a filter using the simplified (recommended) API, and then designs the same filter using the Scipy-compatible API.</p><pre><code class="language-julia-repl hljs">julia&gt; bpass = remez(35, [(0, 0.1)=&gt;0, (0.15, 0.4)=&gt;1, (0.45, 0.5)=&gt;0]);

julia&gt; bpass = remez(35, [0, 0.1, 0.15, 0.4, 0.45, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; bpass2 = remez(35, [(0, 0.08)=&gt;0, (0.15, 0.4)=&gt;1, (0.47, 0.5)=&gt;0]);

julia&gt; bpass2 = remez(35, [0, 0.08, 0.15, 0.4, 0.47, 0.5], [0, 1, 0]);
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; h = remez(20, [(0.1, 0.95) =&gt; 1]; neg=true, Hz=2.0);

julia&gt; h = remez(20, [0.1, 0.95], [1]; filter_type=filter_type_hilbert, Hz=2.0);
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; h = remez(200, [(0.01, 0.99) =&gt; (f -&gt; f/2, f -&gt; 1/f)]; neg=true, Hz=2.0);

julia&gt; h = remez(200, [0.01, 0.99], [1]; filter_type=filter_type_differentiator, Hz=2.0);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/remez_fir.jl#L774-L842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.iirnotch" href="#DSP.Filters.iirnotch"><code>DSP.Filters.iirnotch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iirnotch(Wn::Real, bandwidth::Real[; fs=2])</code></pre><p>Second-order digital IIR notch filter <sup class="footnote-reference"><a id="citeref-Orfanidis" href="#footnote-Orfanidis">[Orfanidis]</a></sup> at frequency <code>Wn</code> with bandwidth <code>bandwidth</code>. If <code>fs</code> is not specified, <code>Wn</code> is interpreted as a normalized frequency in half-cycles/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/design.jl#L519-L528">source</a></section></article><h2 id="Filter-response"><a class="docs-heading-anchor" href="#Filter-response">Filter response</a><a id="Filter-response-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-response" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.freqresp" href="#DSP.Filters.freqresp"><code>DSP.Filters.freqresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H, w = freqresp(filter::FilterCoefficients)</code></pre><p>Frequency response <code>H</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L9-L15">source</a></section><section><div><pre><code class="language-julia hljs">freqresp(filter::FilterCoefficients{:z}, w)</code></pre><p>Frequency response of digital <code>filter</code> at normalized frequency or frequencies <code>w</code> in radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L21-L26">source</a></section><section><div><pre><code class="language-julia hljs">freqresp(filter::FilterCoefficients{:s}, w)</code></pre><p>Frequency response of analog <code>filter</code> at frequency or frequencies <code>w</code> in radians/second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.phaseresp" href="#DSP.Filters.phaseresp"><code>DSP.Filters.phaseresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi, w = phaseresp(filter::FilterCoefficients)</code></pre><p>Phase response <code>phi</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L55-L61">source</a></section><section><div><pre><code class="language-julia hljs">phaseresp(filter::FilterCoefficients, w)</code></pre><p>Phase response of a <code>filter</code> at (normalized) frequency or frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.grpdelay" href="#DSP.Filters.grpdelay"><code>DSP.Filters.grpdelay</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tau, w = grpdelay(filter::FilterCoefficients)</code></pre><p>Group delay <code>tau</code> of a <code>filter</code> at (normalized) frequencies <code>w</code> in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L78-L84">source</a></section><section><div><pre><code class="language-julia hljs">grpdelay(filter::FilterCoefficients{:z}, w)</code></pre><p>Group delay of a digital <code>filter</code> at normalized frequency or frequencies <code>w</code> in radians/sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.impresp" href="#DSP.Filters.impresp"><code>DSP.Filters.impresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impresp(filter::FilterCoefficients{:z}, n=100)</code></pre><p>Impulse response of a digital <code>filter</code> with <code>n</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.stepresp" href="#DSP.Filters.stepresp"><code>DSP.Filters.stepresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stepresp(filter::FilterCoefficients{:z}, n=100)</code></pre><p>Step response of a digital <code>filter</code> with <code>n</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/response.jl#L132-L136">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.coefb" href="#DSP.Filters.coefb"><code>DSP.Filters.coefb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coefb(f::PolynomialRatio)</code></pre><p>Coefficients of the numerator of a <code>PolynomialRatio</code> object, highest power first, i.e., the <code>b</code> passed to <code>filt()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Filters.coefa" href="#DSP.Filters.coefa"><code>DSP.Filters.coefa</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coefa(f::PolynomialRatio)</code></pre><p>Coefficients of the denominator of a <code>PolynomialRatio</code> object, highest power first, i.e., the <code>a</code> passed to <code>filt()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDSP/DSP.jl/blob/ae808aa0640702f4085ddedeb6701e0f0d6f366d/src/Filters/coefficients.jl#L207-L212">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Construct a 4th order elliptic lowpass filter with normalized cutoff frequency 0.2, 0.5 dB of passband ripple, and 30 dB attentuation in the stopband and extract the coefficients of the numerator and denominator of the transfer function:</p><pre><code class="language-julia hljs">responsetype = Lowpass(0.2)
designmethod = Elliptic(4, 0.5, 30)
tf = convert(PolynomialRatio, digitalfilter(responsetype, designmethod))
numerator_coefs = coefb(tf)
denominator_coefs = coefa(tf)</code></pre><p>Filter the data in <code>x</code>, sampled at 1000 Hz, with a 4th order Butterworth bandpass filter between 10 and 40 Hz:</p><pre><code class="language-julia hljs">responsetype = Bandpass(10, 40)
designmethod = Butterworth(4)
filt(digitalfilter(responsetype, designmethod; fs=1000), x)</code></pre><p>Filter the data in <code>x</code>, sampled at 50 Hz, with a 64 tap Hanning window FIR lowpass filter at 5 Hz:</p><pre><code class="language-julia hljs">responsetype = Lowpass(5)
designmethod = FIRWindow(hanning(64))
filt(digitalfilter(responsetype, designmethod; fs=50), x)</code></pre><p>Estimate a Lowpass Elliptic filter order with a normalized passband cutoff frequency of 0.2, a stopband cutoff frequency of 0.4, 3 dB of passband ripple, and 40 dB attenuation in the stopband:</p><pre><code class="language-julia hljs">(N, ωn) = ellipord(0.2, 0.4, 3, 40)</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Rabiner"><a class="tag is-link" href="#citeref-Rabiner">Rabiner</a>Herrmann, O., Lawrence R. Rabiner, and D. S. K. Chan. &quot;Practical design rules for optimum finite impulse response lowpass digital filters.&quot; Bell System Technical Journal 52.6 (1973): 769-799.</li><li class="footnote" id="footnote-McClellan1973a"><a class="tag is-link" href="#citeref-McClellan1973a">McClellan1973a</a>J. H. McClellan and T. W. Parks, A unified approach to the design of optimum FIR linear phase digital filters, IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.</li><li class="footnote" id="footnote-McClellan1973b"><a class="tag is-link" href="#citeref-McClellan1973b">McClellan1973b</a>J. H. McClellan, T. W. Parks and L. R. Rabiner, A Computer Program for Designing Optimum FIR Linear Phase Digital Filters, IEEE Trans. Audio Electroacoust., vol. AU-21, pp. 506-525, 1973.</li><li class="footnote" id="footnote-Orfanidis"><a class="tag is-link" href="#citeref-Orfanidis">Orfanidis</a>Orfanidis, S. J. (1996). Introduction to signal processing. Englewood Cliffs, N.J: Prentice Hall, p. 370.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../windows/">« <code>Windows</code> - window functions</a><a class="docs-footer-nextpage" href="../util/"><code>Util</code> - utility functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 3 December 2024 04:57">Tuesday 3 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
