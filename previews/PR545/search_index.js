var documenterSearchIndex = {"docs":
[{"location":"util/#Util-utility-functions","page":"Util - utility functions","title":"Util - utility functions","text":"","category":"section"},{"location":"util/","page":"Util - utility functions","title":"Util - utility functions","text":"note: Note\nAs of version 0.6.1 of DSP.jl, fftfreq and rfftfreq have been moved from DSP.jl to AbstractFFTs.jl version 0.5 and above. You can also access these functions through FFTW.jl version 1.1 and above.","category":"page"},{"location":"util/","page":"Util - utility functions","title":"Util - utility functions","text":"unwrap\nunwrap!\nhilbert\nnextfastfft\npow2db\namp2db\ndb2pow\ndb2amp\nrms\nrmsfft\nmeanfreq\nfinddelay\nshiftin!\nshiftsignal\nshiftsignal!\nalignsignals\nalignsignals!\ndiric","category":"page"},{"location":"util/#DSP.Unwrap.unwrap","page":"Util - utility functions","title":"DSP.Unwrap.unwrap","text":"unwrap(m; kwargs...)\n\nAssumes m to be a sequence of values that has been wrapped to be inside the given range (centered around zero), and undoes the wrapping by identifying discontinuities. If a single dimension is passed to dims, then m is assumed to have wrapping discontinuities only along that dimension. If a range of dimensions, as in 1:ndims(m), is passed to dims, then m is assumed to have wrapping discontinuities across all ndims(m) dimensions.\n\nA common usage for unwrapping across a singleton dimension is for a phase measurement over time, such as when comparing successive frames of a short-time-fourier-transform, as each frame is wrapped to stay within (-pi, pi].\n\nA common usage for unwrapping across multiple dimensions is for a phase measurement of a scene, such as when retrieving the phase information of of an image, as each pixel is wrapped to stay within (-pi, pi].\n\nArguments\n\nm::AbstractArray{T, N}: Array to unwrap.\ndims=nothing: Dimensions along which to unwrap. If dims is an integer, then   unwrap is called on that dimension. If dims=1:ndims(m), then m is unwrapped   across all dimensions.\nrange=2pi: Range of wrapped array.\ncircular_dims=(false, ...):  When an element of this tuple is true, the   unwrapping process will consider the edges along the corresponding axis   of the array to be connected.\nrng=GLOBAL_RNG: Unwrapping of arrays with dimension > 1 uses a random   initialization. A user can pass their own RNG through this argument.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Unwrap.unwrap!","page":"Util - utility functions","title":"DSP.Unwrap.unwrap!","text":"unwrap!(m; kwargs...)\n\nIn-place version of unwrap.\n\n\n\n\n\nunwrap!(y, m; kwargs...)\n\nUnwrap m storing the result in y, see unwrap.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.hilbert","page":"Util - utility functions","title":"DSP.Util.hilbert","text":"hilbert(x)\n\nComputes the analytic representation of x, x_a = x + j hatx, where hatx is the Hilbert transform of x, along the first dimension of x.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.nextfastfft","page":"Util - utility functions","title":"DSP.Util.nextfastfft","text":"nextfastfft(n)\n\nReturn the closest product of 2, 3, 5, and 7 greater than or equal to n. FFTW contains optimized kernels for these sizes and computes Fourier transforms of input that is a product of these sizes faster than for input of other sizes.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.pow2db","page":"Util - utility functions","title":"DSP.Util.pow2db","text":"pow2db(a)\n\nConvert a power ratio to dB (decibel), or 10log_10(a). The inverse of db2pow.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.amp2db","page":"Util - utility functions","title":"DSP.Util.amp2db","text":"amp2db(a)\n\nConvert an amplitude ratio to dB (decibel), or 20 log_10(a)=10log_10(a^2). The inverse of db2amp.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.db2pow","page":"Util - utility functions","title":"DSP.Util.db2pow","text":"db2pow(a)\n\nConvert dB to a power ratio. This function call also be called using a*dB, i.e. 3dB == db2pow(3). The inverse of pow2db.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.db2amp","page":"Util - utility functions","title":"DSP.Util.db2amp","text":"db2amp(a)\n\nConvert dB to an amplitude ratio. This function call also be called using a*dBa, i.e. 3dBa == db2amp(3). The inverse of amp2db.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.rms","page":"Util - utility functions","title":"DSP.Util.rms","text":"rms(s; dims)\n\nReturn the root mean square (rms) of signal s. Optional keyword parameter dims can be used to specify the dimensions along which to compue the rms.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.rmsfft","page":"Util - utility functions","title":"DSP.Util.rmsfft","text":"rmsfft(f)\n\nReturn the root mean square of signal s given the FFT transform f = fft(s). Equivalent to rms(ifft(f)).\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.meanfreq","page":"Util - utility functions","title":"DSP.Util.meanfreq","text":"meanfreq(x, fs)\n\nCalculate the mean power frequency of x with a sampling frequency of fs, defined as:\n\nMPF = fracsum_i=1^F f_i X_i^2 sum_i=0^F X_i^2  Hz\n\nwhere F is the Nyquist frequency, and X is the power spectral density.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.finddelay","page":"Util - utility functions","title":"DSP.Util.finddelay","text":"finddelay(x, y)\n\nEstimate the delay of x with respect to y by locating the peak of their cross-correlation.\n\nThe output delay will be positive when x is delayed with respect y, negative if advanced, 0 otherwise.\n\nExample\n\njulia> finddelay([0, 0, 1, 2, 3], [1, 2, 3])\n2\n\njulia> finddelay([1, 2, 3], [0, 0, 1, 2, 3])\n-2\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.shiftin!","page":"Util - utility functions","title":"DSP.Util.shiftin!","text":"shiftin!(a::AbstractVector{T}, b::AbstractVector{T}) where T\n\nShifts b into the end of a.\n\njulia> shiftin!([1,2,3,4], [5, 6])\n4-element Vector{Int64}:\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.shiftsignal","page":"Util - utility functions","title":"DSP.Util.shiftsignal","text":"shiftsignal(x, s)\n\nShift elements of signal x in time by a given amount s of samples and fill the spaces with zeros. For circular shifting, use circshift.\n\nExample\n\njulia> shiftsignal([1, 2, 3], 2)\n3-element Vector{Int64}:\n 0\n 0\n 1\n\njulia> shiftsignal([1, 2, 3], -2)\n3-element Vector{Int64}:\n 3\n 0\n 0\n\nSee also shiftsignal!.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.shiftsignal!","page":"Util - utility functions","title":"DSP.Util.shiftsignal!","text":"shiftsignal!(x, s)\n\nMutating version of shiftsignals(): shift x of s samples and fill the spaces with zeros in-place.\n\nSee also shiftsignal.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.alignsignals","page":"Util - utility functions","title":"DSP.Util.alignsignals","text":"alignsignals(x, y)\n\nUse finddelay() and shiftsignal() to time align x to y. Also return the delay of x with respect to y.\n\nExample\n\njulia> alignsignals([0, 0, 1, 2, 3], [1, 2, 3])\n([1, 2, 3, 0, 0], 2)\n\njulia> alignsignals([1, 2, 3], [0, 0, 1, 2, 3])\n([0, 0, 1], -2)\n\nSee also alignsignals!.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.Util.alignsignals!","page":"Util - utility functions","title":"DSP.Util.alignsignals!","text":"alignsignals!(x, y)\n\nMutating version of alignsignals(): time align x to y in-place.\n\nSee also alignsignals.\n\n\n\n\n\n","category":"function"},{"location":"util/#DSP.diric","page":"Util - utility functions","title":"DSP.diric","text":"kernel = diric(Ω::Real, n::Integer)\n\nDirichlet kernel, also known as periodic sinc function, where n should be a positive integer.\n\nTypically returns fracsin(Ω cdot n2)n * sin(Ω  2), but returns 1 when Ω is a multiple of 2π.\n\nIn the usual case where n is odd, the output is equivalent to frac1n sum_k=-(n-1)2^(n-1)2 e^i k Ω, which is the discrete-time Fourier transform (DTFT) of a n-point moving average filter.\n\nWhen n is odd or even, the function is 2π or 4π periodic, respectively. The formula for general n is\n\nmathrmdiric(Ωn) = frace^-i (n-1) Ω2n sum_k=0^n-1 e^i k Ω\n\nwhich is a real and symmetric function of Ω.\n\nAs of 2021-03-19, the Wikipedia definition has different factors. The definition here is consistent with scipy and other software frameworks.\n\nExamples\n\njulia> round.(diric.((-2:0.5:2)*π, 5), digits=9)'\n1×9 adjoint(::Vector{Float64}) with eltype Float64:\n 1.0  -0.2  0.2  -0.2  1.0  -0.2  0.2  -0.2  1.0\n\njulia> diric(0, 4)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"appendix/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"appendix/","page":"Index","title":"Index","text":"","category":"page"},{"location":"windows/#Windows-window-functions","page":"Windows - window functions","title":"Windows - window functions","text":"","category":"section"},{"location":"windows/","page":"Windows - window functions","title":"Windows - window functions","text":"rect\nhanning\nhamming\ntukey\ncosine\nlanczos\ntriang\nbartlett\ngaussian\nbartlett_hann\nblackman\nkaiser\ndpss\ndpsseig","category":"page"},{"location":"windows/#DSP.Windows.rect","page":"Windows - window functions","title":"DSP.Windows.rect","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀│ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n  │                                                                      │ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nrect(n::Integer; padding::Integer=0, zerophase::Bool=false)\nrect(dims; padding=0, zerophase=false)\n\nRectangular window of length n, padded with padding zeros. This window is 1 within the window, and 0 outside of it.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.hanning","page":"Windows - window functions","title":"DSP.Windows.hanning","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                             ▄▄▀▀▀▀▀▀▀▀▄▄                             │ \n  │                          ▗▄▀            ▀▄▖                          │ \n  │                        ▗▞▘                ▝▚▖                        │ \n  │                       ▄▘                    ▝▄                       │ \n  │                     ▗▀                        ▀▖                     │ \n  │                    ▞▘                          ▝▚                    │ \n  │                  ▗▀                              ▀▖                  │ \n  │                ▗▄▘                                ▝▚▖                │ \n  │               ▄▘                                    ▝▄               │ \n  │             ▗▞                                        ▚▖             │ \n  │            ▄▘                                          ▝▄            │ \n  │          ▗▀                                              ▀▖          │ \n  │        ▗▞▘                                                ▝▚▖        │ \n  │      ▄▀▘                                                    ▝▀▄      │ \n0 │▄▄▄▄▀▀                                                          ▀▀▄▄▄▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nhanning(n::Integer; padding::Integer=0, zerophase::Bool=false)\nhanning(dims; padding=0, zerophase=false)\n\nHanning window of length n with padding zeros. The Hanning (or Hann) window is a raised-cosine window that reaches zero at the endpoints.\n\nThe window is defined by sampling the continuous function:\n\n       1 + cos(2πx)\nw(x) = ──────────── = cos²(πx)\n            2\n\nin the range [-0.5, 0.5]\n\nThe hanning window satisfies the Constant Overlap-Add (COLA) property with a hop of 0.5, which means that adding together a sequence of delayed windows with 50% overlap will result in a constant signal. This is useful when synthesizing a signal from a number of overlapping frames (each with a roughly rectangular window), to eliminate windowing amplitude modulation.\n\nWhile this windowing function was originally named after its inventor Julius Von Hann, colloquial usage has adjusted to refer to it as the \"Hanning\" window, to better match the similarly-named \"Hamming\" window.  Because of this, both hann() and hanning() are exported from this module.\n\nNote that the hanning window is the cosine window squared.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.hamming","page":"Windows - window functions","title":"DSP.Windows.hamming","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                             ▄▞▀▀▀▀▀▀▀▀▚▄                             │ \n  │                          ▗▞▀            ▀▚▖                          │ \n  │                        ▗▞▘                ▝▀▄                        │ \n  │                      ▗▞▘                     ▚▖                      │ \n  │                     ▞▘                        ▝▚▖                    │ \n  │                   ▄▀                            ▀▄                   │ \n  │                 ▄▞                                ▚▄                 │ \n  │               ▗▞                                    ▚▖               │ \n  │              ▞▘                                      ▝▚              │ \n  │            ▄▀                                          ▀▄            │ \n  │          ▗▞                                              ▚▖          │ \n  │        ▄▞▘                                                ▝▚▄        │ \n  │     ▗▄▀▘                                                     ▀▄▖     │ \n  │▄▄▄▞▀▘                                                          ▝▀▚▄▄▄│ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nhamming(n::Integer; padding::Integer=0, zerophase::Bool=false)\nhamming(dims; padding=0, zerophase=false)\n\nHamming window of length n with padding zeros. The Hamming window does not reach zero at the endpoints and so has a shallower frequency roll-off when compared to the Hanning window, but is designed to cancel the first side-lobe.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.54 + 0.46*cos(2pi*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.tukey","page":"Windows - window functions","title":"DSP.Windows.tukey","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │           ▗▞▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▜▖           │ \n  │          ▗▘                                              ▝▖          │ \n  │         ▗▘                                                ▝▖         │ \n  │         ▞                                                  ▚         │ \n  │        ▐                                                    ▌        │ \n  │        ▌                                                    ▝▖       │ \n  │       ▐                                                      ▚       │ \n  │      ▗▘                                                      ▝▖      │ \n  │      ▌                                                        ▚      │ \n  │     ▗▘                                                         ▌     │ \n  │     ▌                                                          ▐     │ \n  │    ▞                                                            ▚    │ \n  │   ▞▘                                                            ▝▖   │ \n  │  ▗▘                                                              ▝▖  │ \n0 │▄▄▘                                                                ▝▚▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\ntukey(n::Integer, α::Real; padding::Integer=0, zerophase::Bool=false)\ntukey(dims, α; padding=0, zerophase=false)\n\nTukey window of length n with padding zeros. The Tukey window has a flat top and reaches zero at the endpoints, with a sinusoidal transition area parameterized by α. For α == 0, the window is equivalent to a rectangular window. For α == 1, the window is a Hann window.\n\nThe window is defined by sampling the continuous function:\n\n       ⎛              ⎛2π ⎛    1 - α⎞⎞\n       ⎜      1 + cos ⎜── ⎜x + ─────⎟⎟             1 - α\n       ⎜              ⎝ α ⎝      2  ⎠⎠       x ≤ - ─────\n       ⎜      ─────────────────────────              2\n       ⎜                  2\n       ⎜\n       ⎜                                       1 - α       1 - α\nw(x) = ⎜      1                              - ───── < x ≤ ─────\n       ⎜                                         2           2\n       ⎜\n       ⎜              ⎛2π ⎛    1 - α⎞⎞\n       ⎜      1 + cos ⎜── ⎜x - ─────⎟⎟           1 - α\n       ⎜              ⎝ α ⎝      2  ⎠⎠       x > ─────\n       ⎜      ─────────────────────────            2\n       ⎝                  2\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. α, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.cosine","page":"Windows - window functions","title":"DSP.Windows.cosine","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                           ▄▄▀▀▀▀▀▀▀▀▀▀▀▀▄▄                           │ \n  │                       ▗▄▀▀                ▀▀▄▖                       │ \n  │                     ▄▀▘                      ▝▀▄                     │ \n  │                  ▗▞▀                            ▀▚▖                  │ \n  │                ▄▀▘                                ▝▀▄                │ \n  │              ▄▀                                      ▀▄              │ \n  │            ▗▞                                          ▚▖            │ \n  │           ▞▘                                            ▝▚▖          │ \n  │         ▄▀                                                ▝▄         │ \n  │       ▗▞                                                    ▚▖       │ \n  │      ▄▘                                                      ▝▄      │ \n  │    ▗▞                                                          ▚▖    │ \n  │   ▄▘                                                            ▝▄   │ \n  │ ▗▞                                                                ▚▖ │ \n0 │▄▘                                                                  ▝▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\ncosine(n::Integer; padding::Integer=0, zerophase::Bool=false)\ncosine(dims; padding=0, zerophase=false)\n\nCosine window of length n with padding zeros. The cosine window is the first lobe of a cosine function (with the zero crossings at +/- π as endpoints). Also called the sine window.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = cos(πx)\n\nin the range [-0.5, 0.5]\n\nNote that the cosine window is the square root of the hanning window, so it is sometimes used when you are applying the window twice, such as the analysis and synthesis steps of an STFT.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.lanczos","page":"Windows - window functions","title":"DSP.Windows.lanczos","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                            ▄▄▀▀▀▀▀▀▀▀▀▀▄▄                            │ \n  │                         ▄▞▀              ▀▀▄                         │ \n  │                      ▗▞▀                    ▀▚▖                      │ \n  │                    ▗▞▘                        ▝▚▖                    │ \n  │                  ▗▞▘                            ▝▚▖                  │ \n  │                ▗▀▘                                ▝▀▖                │ \n  │              ▗▞▘                                    ▝▚▖              │ \n  │             ▄▘                                        ▝▚             │ \n  │           ▄▀                                            ▀▄           │ \n  │         ▗▞▘                                               ▚▖         │ \n  │        ▄▘                                                  ▝▚        │ \n  │      ▄▀                                                      ▀▄      │ \n  │    ▗▞                                                          ▜▖    │ \n  │  ▗▞▘                                                            ▝▚▖  │ \n0 │▄▞▘                                                                ▝▚▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nlanczos(n::Integer; padding::Integer=0, zerophase::Bool=false)\nlanczos(dims; padding=0, zerophase=false)\n\nLanczos window of length n with padding zeros. The Lanczos window is the main lobe of a sinc function.\n\nThe window is defined by sampling the continuous function:\n\n                  sin(2πx)\nw(x) = sinc(2x) = ────────\n                     2πx\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.triang","page":"Windows - window functions","title":"DSP.Windows.triang","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                                ▄▞▀▀▀▄▖                               │ \n  │                            ▗▄▞▀      ▝▀▄▖                            │ \n  │                         ▗▄▀▘            ▝▀▄▖                         │ \n  │                      ▗▄▀▘                  ▝▀▄▖                      │ \n  │                   ▗▄▀▘                        ▝▀▄▖                   │ \n  │                ▗▄▀▘                              ▝▀▄▄                │ \n  │             ▗▄▀▘                                     ▀▚▄             │ \n  │          ▗▄▀▘                                           ▀▙▄          │ \n  │       ▄▄▀▘                                                 ▀▚▄       │ \n  │    ▄▞▀                                                        ▀▚▄    │ \n  │ ▄▞▀                                                              ▀▚▄ │ \n  │▀                                                                    ▀│ \n  │                                                                      │ \n  │                                                                      │ \n0 │                                                                      │ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                    7  \n\ntriang(n::Integer; padding::Integer=0, zerophase::Bool=false)\ntriang(dims; padding=0, zerophase=false)\n\nTriangular window of length n with padding zeros. The Triangular window does not reach zero at the endpoints. For odd n the triang window is the center n points of an n+2-point bartlett window (i.e. the samples just outside the window would be zero). For even n the window slope is the same as the n-1 window but delayed by a half sample so the zero points would be 1/2 sample past the ends of the window.\n\nThe window is defined by sampling the continuous function:\n\n        ⎛    2(n-1)\n        ⎜1 - ────── abs(x)     n is even\n        ⎜       n\nw(x) =  ⎜\n        ⎜    2(n-1)\n        ⎜1 - ────── abs(x)     n is odd\n        ⎝     n+1\n\nin the range [-0.5, 0.5].\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\nWhen zerophase is true substitute n+1 for n in the above window expressions.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.bartlett","page":"Windows - window functions","title":"DSP.Windows.bartlett","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                                ▗▞▀▀▚▖                                │ \n  │                              ▄▞▘    ▝▚▄                              │ \n  │                            ▄▀          ▀▄                            │ \n  │                         ▗▄▀              ▀▄▖                         │ \n  │                       ▗▞▘                  ▝▚▖                       │ \n  │                     ▄▞▘                      ▝▚▄                     │ \n  │                   ▄▀                            ▀▄                   │ \n  │                ▄▄▀                                ▀▚▄                │ \n  │              ▄▀                                      ▀▄              │ \n  │           ▗▞▀                                          ▀▚▖           │ \n  │         ▗▞▘                                              ▝▚▖         │ \n  │       ▄▀▘                                                  ▝▀▄       │ \n  │     ▄▀                                                        ▀▄     │ \n  │  ▗▞▀                                                            ▀▚▖  │ \n0 │▄▞▘                                                                ▝▚▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nbartlett(n::Integer; padding::Integer=0, zerophase::Bool=false)\nbartlett(dims; padding=0, zerophase=false)\n\nBartlett window of length n. The Bartlett window is a triangular window that reaches 0 at the endpoints. This is equivalent to convolving two rectangular windows of length (n-1)/2 and adding the zero endpoints. See triang for a window that does not reach zero at the endpoints.\n\nThe window is defined by sampling the continuous function:\n\n1 - abs(2x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.gaussian","page":"Windows - window functions","title":"DSP.Windows.gaussian","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                             ▗▄▞▀▀▀▀▀▀▀▄▖                             │ \n  │                           ▗▞▘          ▝▚▖                           │ \n  │                         ▗▞▘              ▝▚▖                         │ \n  │                        ▄▘                  ▝▄                        │ \n  │                      ▗▞                      ▚▖                      │ \n  │                     ▄▘                        ▝▙                     │ \n  │                   ▗▞                            ▀▖                   │ \n  │                  ▟▘                              ▝▚                  │ \n  │                ▞▀                                  ▀▚                │ \n  │              ▄▀                                      ▀▄              │ \n  │            ▄▀                                          ▀▄            │ \n  │          ▄▀                                              ▀▄          │ \n  │       ▄▞▀                                                  ▀▚▄       │ \n  │  ▗▄▄▀▀                                                        ▀▀▄▄▖  │ \n0 │▀▀▘                                                                ▝▀▀│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\ngaussian(n::Integer, σ::Real; padding::Integer=0, zerophase::Bool=false)\ngaussian(dims, σ; padding=0, zerophase=false)\n\nGives an n-sample gaussian window defined by sampling the function:\n\n        ⎛        2⎞\n        ⎜-1   ⎛x⎞ ⎟\n        ⎜── ⋅ ⎜─⎟ ⎟\n        ⎝ 2   ⎝σ⎠ ⎠\nw(x) = e\n\nin the range [-0.5,0.5]. This means that for σ=0.5 the endpoints of the window will correspond to 1 standard deviation away from the center.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. σ, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.bartlett_hann","page":"Windows - window functions","title":"DSP.Windows.bartlett_hann","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                              ▄▄▀▀▀▀▀▀▄▄                              │ \n  │                           ▗▟▀          ▀▚▖                           │ \n  │                         ▗▞▘              ▝▚▖                         │ \n  │                       ▗▞▘                  ▝▚▖                       │ \n  │                      ▞▘                      ▝▚                      │ \n  │                    ▄▀                          ▀▄                    │ \n  │                  ▗▞                              ▚▖                  │ \n  │                ▗▄▘                                ▝▚▖                │ \n  │               ▞▘                                    ▝▚               │ \n  │             ▄▀                                        ▀▄             │ \n  │           ▗▞                                            ▚▖           │ \n  │         ▗▞▘                                              ▝▚▖         │ \n  │       ▗▞▘                                                  ▝▚▖       │ \n  │     ▄▞▘                                                      ▝▜▄     │ \n0 │▄▄▄▀▀                                                            ▀▀▄▄▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nbartlett_hann(n::Integer; padding::Integer=0, zerophase::Bool=false)\nbartlett_hann(dims; padding=0, zerophase=false)\n\nBartlett-Hann window of length n with padding zeros. The Bartlett-Hann window is a weighted sum of the Bartlett and Hann windows.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.62 - 0.48*abs(x) + 0.38*cos(2π*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.blackman","page":"Windows - window functions","title":"DSP.Windows.blackman","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                              ▗▞▀▀▀▀▀▀▚▖                              │ \n  │                            ▗▞▘        ▝▚▖                            │ \n  │                           ▞▘            ▝▚                           │ \n  │                         ▗▀                ▀▖                         │ \n  │                        ▄▘                  ▝▙                        │ \n  │                       ▞                      ▚                       │ \n  │                     ▗▀                        ▀▖                     │ \n  │                    ▗▘                          ▝▖                    │ \n  │                   ▞▘                            ▝▚                   │ \n  │                 ▄▞                                ▚▄                 │ \n  │               ▗▞                                    ▚▖               │ \n  │              ▞▘                                      ▝▚              │ \n  │           ▗▄▀                                          ▀▄▖           │ \n  │         ▄▞▘                                              ▝▚▄▖        │ \n0 │▄▄▄▄▄▄▞▀▀                                                    ▝▀▚▄▄▄▄▄▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nblackman(n::Integer; padding::Integer=0, zerophase::Bool=false)\nblackman(dims; padding=0, zerophase=false)\n\nApproximates the \"Exact\" Blackman window. This is the generalized Blackman window with α = 0.16.\n\nThe window is defined by sampling the continuous function:\n\nw(x) = 0.42 + 0.5*cos(2π*x) + 0.08*cos(4π*x)\n\nin the range [-0.5, 0.5]\n\nProviding a dims Tuple rather than a single n constructs a 2D window. padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.kaiser","page":"Windows - window functions","title":"DSP.Windows.kaiser","text":"  ┌──────────────────────────────────────────────────────────────────────┐ \n1 │                              ▗▄▀▀▀▀▀▀▄▖                              │ \n  │                            ▗▞▘        ▝▚▖                            │ \n  │                           ▄▘            ▝▄                           │ \n  │                          ▞                ▚                          │ \n  │                        ▗▀                  ▀▖                        │ \n  │                       ▗▘                    ▝▖                       │ \n  │                      ▄▘                      ▝▄                      │ \n  │                     ▞                          ▚                     │ \n  │                   ▗▞                            ▚▖                   │ \n  │                  ▗▘                              ▝▖                  │ \n  │                ▗▀▘                                ▝▀▖                │ \n  │              ▗▞▘                                    ▝▚▖              │ \n  │            ▗▞▘                                        ▝▚▖            │ \n  │         ▗▄▞▘                                            ▝▚▄▖         │ \n0 │▄▄▄▄▄▄▄▞▀▘                                                  ▝▀▚▄▄▄▄▄▄▄│ \n  └──────────────────────────────────────────────────────────────────────┘ \n   1                                                                   69  \n\nkaiser(n::Integer, α::Real; padding::Integer=0, zerophase::Bool=false)\nkaiser(dims, α; padding=0, zerophase=false)\n\nKaiser window of length n parameterized by α. The Kaiser window approximates the DPSS window (given by dpss), using a simplified definition relying on a Bessel function. Larger values for α give a wider main lobe but have lower sidelobes. Typically α is set around 3.\n\nThe window is defined by sampling the continuous function:\n\n         ⎛  ⎛   _________⎞⎞\n         ⎜  ⎜  ╱        2⎟⎟\nw(x) = I₀⎝πα⎝╲╱ 1 - (2x) ⎠⎠\n       ────────────────────\n               I₀(πα)\n\nin the range [-0.5, 0.5]\n\nWhere I₀(⋅) is the zeroth-order modified Bessel function of the first kind.\n\nProviding a dims Tuple rather than a single n constructs a 2D window. α, padding and zerophase can then be given either as a single value for both horizontal and vertical or a 2-tuple to specify them separately.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.dpss","page":"Windows - window functions","title":"DSP.Windows.dpss","text":"    ┌──────────────────────────────────────────────────────────────────────┐ \n0.2 │                             ▗▄▞▀▀▀▀▀▀▚▄▖                             │ \n    │                           ▄▀▘          ▝▀▄                           │ \n    │                         ▄▀                ▀▄                         │ \n    │                       ▗▞                    ▀▖                       │ \n    │                      ▞▘                      ▝▚                      │ \n    │                    ▗▀                          ▀▄                    │ \n    │                  ▗▞▘                             ▚▖                  │ \n    │                ▗▄▀                                ▝▄▖                │ \n    │               ▄▘                                    ▝▄               │ \n    │             ▗▞                                        ▚▖             │ \n    │           ▗▞▘                                          ▝▚▖           │ \n    │         ▗▞▘                                              ▝▚▖         │ \n    │       ▄▞▘                                                  ▝▚▄       │ \n    │    ▄▄▀▘                                                       ▀▚▄    │ \n  0 │▄▞▀▀                                                              ▀▀▚▄│ \n    └──────────────────────────────────────────────────────────────────────┘ \n     1                                                                   69  \n\ndpss(n::Integer, nw::Real, ntapers::Integer=iceil(2*nw)-1;\n     padding::Integer=0, zerophase::Bool=false)\n\nThe first ntapers discrete prolate spheroid sequences (Slepian tapers) as an n × ntapers matrix. The signs of the tapers follow the convention that the first element of the skew-symmetric (odd) tapers is positive. The time-bandwidth product is given by nw.\n\nThe DPSS window maximizes the energy concentration in the main lobe.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\n\n\n\n\n","category":"function"},{"location":"windows/#DSP.Windows.dpsseig","page":"Windows - window functions","title":"DSP.Windows.dpsseig","text":"dpsseig(A, nw)\n\nEigenvalues of the DPSS matrix, representing the ratios of the power within the main lobe to the total power (main and sidelobes). A is the output of dpss, and nw is the time-bandwidth product provided to dpss as input.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#Convolutions-similarity-methods","page":"Convolutions - similarity methods","title":"Convolutions - similarity methods","text":"","category":"section"},{"location":"convolutions/","page":"Convolutions - similarity methods","title":"Convolutions - similarity methods","text":"conv\nconv!\ndeconv\nxcorr","category":"page"},{"location":"convolutions/#DSP.conv","page":"Convolutions - similarity methods","title":"DSP.conv","text":"conv(u, v; algorithm)\n\nConvolution of two arrays. Uses either direct convolution, FFT convolution, or overlap-save, depending on the size of the input unless explicitly specified with the algorithm keyword argument; see conv! for details. u and v can be N-dimensional arrays, with arbitrary indexing offsets, but their axes must be a UnitRange.\n\n\n\n\n\nconv(u,v,A)\n\n2-D convolution of the matrix A with the 2-D separable kernel generated by the vectors u and v. Uses 2-D FFT algorithm.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#DSP.conv!","page":"Convolutions - similarity methods","title":"DSP.conv!","text":"conv!(out, u, v; algorithm=:auto)\n\nConvolution of two arrays u and v with the result stored in out. out must be large enough to store the entire result; if it is even larger, the excess entries will be zeroed.\n\nout, u, and v can be N-dimensional arrays, with arbitrary indexing offsets, but their axes must be a UnitRange. If none of them has offset axes, size(out,d) ≥ size(u,d) + size(v,d) - 1 must hold. If both input and output have offset axes, firstindex(out,d) ≤ firstindex(u,d) + firstindex(v,d) and lastindex(out,d) ≥ lastindex(u,d) + lastindex(v,d) must hold (for d = 1,...,N). A mix of offset and non-offset axes between input and output is not permitted.\n\nThe algorithm keyword allows choosing the algorithm to use:\n\n:direct: Evaluates the convolution sum in time domain.\n:fft_simple: Evaluates the convolution as a product in the frequency domain.\n:fft_overlapsave: Evaluates the convolution block-wise as a product in the frequency domain, overlapping the resulting blocks.\n:fft: Chooses between the faster one (as estimated form the input size) of :fft_simple and :fft_overlapsave.\n:fast: Chooses between the faster one (as estimated form the input size) of :direct, :fft_simple and :fft_overlapsave.\n:auto (default): Equivalent to :fast if the data type is known to be suitable for FFT-based computation, equivalent to :direct otherwise.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#DSP.deconv","page":"Convolutions - similarity methods","title":"DSP.deconv","text":"deconv(b,a) -> c\n\nConstruct vector c such that b = conv(a,c) + r. Equivalent to polynomial division.\n\n\n\n\n\n","category":"function"},{"location":"convolutions/#DSP.xcorr","page":"Convolutions - similarity methods","title":"DSP.xcorr","text":"xcorr(u; padmode::Symbol=:none, scaling::Symbol=:none)\nxcorr(u, v; padmode::Symbol=:none, scaling::Symbol=:none)\n\nWith two arguments, compute the cross-correlation of two vectors, by calculating the similarity between u and v with various offsets of v. Delaying u relative to v will shift the result to the right. If one argument is provided, calculate xcorr(u, u; kwargs...).\n\nThe size of the output depends on the padmode keyword argument: with padmode = :none the length of the result will be length(u) + length(v) - 1, as with conv. With padmode = :longest, the shorter of the arguments will be padded so they are of equal length. This gives a result with length 2*max(length(u), length(v))-1, with the zero-lag condition at the center.\n\nThe keyword argument scaling can be provided. Possible arguments are the default :none and :biased. :biased is valid only if the vectors have the same length, or only one vector is provided, dividing the result by length(u).\n\nExamples\n\njulia> xcorr([1,2,3],[1,2,3])\n5-element Vector{Int64}:\n  3\n  8\n 14\n  8\n  3\n\n\n\n\n\n","category":"function"},{"location":"estimation/#Estimation-parametric-estimation-functions","page":"Estimation - parametric estimation functions","title":"Estimation - parametric estimation functions","text":"","category":"section"},{"location":"estimation/","page":"Estimation - parametric estimation functions","title":"Estimation - parametric estimation functions","text":"esprit\njacobsen\nquinn","category":"page"},{"location":"estimation/#DSP.Estimation.esprit","page":"Estimation - parametric estimation functions","title":"DSP.Estimation.esprit","text":"esprit(x::AbstractArray, M::Integer, p::Integer, Fs::Real=1.0)\n\nESPRIT [Roy1986] algorithm for frequency estimation. Estimation of Signal Parameters via Rotational Invariance Techniques\n\nGiven length N signal \"x\" that is the sum of p sinusoids of unknown frequencies, estimate and return an array of the p frequencies.\n\nArguments\n\nx::AbstractArray: complex length N signal array\nM::Integer: size of correlation matrix, must be <= N.     The signal subspace is computed from the SVD of an M x (N-M+1) signal matrix     formed from N-M+1 length-M shifts of the signal x in its columns.     For best performance for 1 sinusoid, use M = (N+1)/3 (according to van der Veen and Leus).     For faster execution (due to smaller SVD), use small M or small N-M\np::Integer: number of sinusoids to estimate.\nFs::Float64: sampling frequency, in Hz.\n\nReturns\n\nlength p real array of frequencies in units of Hz.\n\n[Roy1986]: R Roy, A Paulraj and T Kailath, ESPRIT - A subspace approach to estimation of parameters of cisoids in noise, IEEE Trans. Acoustics, Speech, Signal Process., 34, 1340-1342 (1986). http://ieeexplore.ieee.org/abstract/document/1164935/.\n\n\n\n\n\n","category":"function"},{"location":"estimation/#DSP.Estimation.jacobsen","page":"Estimation - parametric estimation functions","title":"DSP.Estimation.jacobsen","text":"jacobsen(x::AbstractVector, Fs::Real = 1.0)\n\nEstimate the largest frequency in the complex signal x using Jacobsen's algorithm [Jacobsen2007]. Argument Fs is the sampling frequency.  All frequencies are expressed in Hz.\n\nIf the signal x is real, the estimated frequency is guaranteed to be positive, but it may be highly inaccurate (especially for frequencies close to zero or to Fs/2).\n\nIf the sampling frequency Fs is not provided, then it is assumed that Fs = 1.0.\n\n[Jacobsen2007]: E Jacobsen and P Kootsookos, \"Fast, Accurate Frequency Estimators\", Chapter\n\n10 in \"Streamlining Digital Signal Processing\", edited by R. Lyons, 2007, IEEE Press.\n\n\n\n\n\n","category":"function"},{"location":"estimation/#DSP.Estimation.quinn","page":"Estimation - parametric estimation functions","title":"DSP.Estimation.quinn","text":"quinn(x::Vector, f0::Real, Fs::Real = 1.0 ; tol = 1e-6, maxiters = 20)\n\nquinn(x::Vector, Fs::Real = 1.0 ; kwargs...)\n\nquinn(x::Vector ; kwargs...)\n\nAlgorithms by Quinn and Quinn & Fernandes for frequency estimation. Given a signal x and an initial guess f0, estimate and return the frequency of the largest sinusoid in x. Fs is the sampling frequency. All frequencies are expressed in Hz.\n\nIf the initial guess f0 is not provided, then a guess is calculated using Jacobsen's estimator. If the sampling frequency Fs is not provided, then it is assumed that Fs = 1.0.\n\nThe following keyword arguments control the algorithm's behavior:\n\ntol: the algorithm stops when the absolut value of the difference between  two consecutive estimates is less than tol. Defaults to 1e-6.\nmaxiters: the maximum number of iterations to run. Defaults to 20.\n\nReturns a tuple (estimate, reachedmaxiters), where estimate is the estimated frequency, and reachedmaxiters is true if the algorithm finished after running for maxiters iterations (this may indicate that the algorithm did not converge).\n\nIf the signal x is real, then the algorithm used is [Quinn1991]. If the signal is complex, the algorithm is [Quinn2009].\n\n[Quinn1991]: B Quinn and J Fernandes, \"A fast efficient technique for the\n\nestimation of frequency\", Biometrika, Vol. 78 (1991).\n\n[Quinn2009]: B Quinn, \"Recent advances in rapid frequency estimation\", Digital\n\nSignal Processing, Vol. 19 (2009), Elsevier.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filters-filter-design-and-filtering","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl differentiates between filter coefficients and stateful filters. Filter coefficient objects specify the response of the filter in one of several standard forms. Stateful filter objects carry the state of the filter together with filter coefficients in an implementable form (PolynomialRatio, Biquad, or SecondOrderSections). When invoked on a filter coefficient object, filt does not preserve state.","category":"page"},{"location":"filters/#coefficient-objects","page":"Filters - filter design and filtering","title":"Filter coefficient objects","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl supports common filter representations. Filter coefficients can be converted from one type to another using convert.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"ZeroPoleGain\nPolynomialRatio\nBiquad\nSecondOrderSections","category":"page"},{"location":"filters/#DSP.Filters.ZeroPoleGain","page":"Filters - filter design and filtering","title":"DSP.Filters.ZeroPoleGain","text":"ZeroPoleGain(z, p, k)\n\nFilter representation in terms of zeros z, poles p, and gain k:\n\nH(x) = kfrac(x - verbz1) ldots (x - verbzm)(x - verbp1) ldots (x - verbpn)\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.PolynomialRatio","page":"Filters - filter design and filtering","title":"DSP.Filters.PolynomialRatio","text":"PolynomialRatio(b, a)\n\nFilter representation in terms of the coefficients of the numerator b and denominator a in the z or s domain where b and a are vectors ordered from highest power to lowest. Filter with:\n\nTransfer function in z domain (zero & negative z powers):\n\nH(z) = fracverbb1 + ldots + verbbm z^-m+1verba1 + ldots + verban z^-n+1\n\nreturns PolynomialRatio object with a[1] = 1 and other specified coefficients divided by a[1].\n\njulia> PolynomialRatio([1,1],[1,2])\nPolynomialRatio{:z, Float64}(LaurentPolynomial(1.0*z⁻¹ + 1.0), LaurentPolynomial(2.0*z⁻¹ + 1.0))\njulia> PolynomialRatio{:z}([1,2,3],[2,3,4])\nPolynomialRatio{:z, Float64}(LaurentPolynomial(1.5*z⁻² + 1.0*z⁻¹ + 0.5), LaurentPolynomial(2.0*z⁻² + 1.5*z⁻¹ + 1.0))\n\nTransfer function in s domain (zero & positive s powers):\n\nH(s) = fracverbb1 s^m-1 + ldots + verbbmverba1 s^n-1 + ldots + verban\n\nreturns PolynomialRatio object with specified b and a coefficients.\n\njulia> PolynomialRatio{:s}([1,2,3],[2,3,4])\nPolynomialRatio{:s, Int64}(LaurentPolynomial(3 + 2*s + s²), LaurentPolynomial(4 + 3*s + 2*s²))\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Biquad","page":"Filters - filter design and filtering","title":"DSP.Filters.Biquad","text":"Biquad(b0, b1, b2, a1, a2)\n\nFilter representation in terms of the transfer function of a single second-order section given by:\n\nH(s) = fracverbb0 s^2+verbb1 s+verbb2s^2+verba1 s + verba2\n\nor equivalently:\n\nH(z) = fracverbb0+verbb1 z^-1+verbb2 z^-21+verba1 z^-1 + verba2 z^-2\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.SecondOrderSections","page":"Filters - filter design and filtering","title":"DSP.Filters.SecondOrderSections","text":"SecondOrderSections(biquads, gain)\n\nFilter representation in terms of a cascade of second-order sections and gain. biquads must be specified as a vector of Biquads.\n\n\n\n\n\n","category":"type"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"These filter coefficient objects support the following arithmetic operations: inversion (inv), multiplication (*) for series connection, and integral power (^) for repeated multiplication with itself. For example:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"julia> H = PolynomialRatio([1.0], [1.0, 0.3])\nPolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.3*z⁻¹ + 1.0))\n\njulia> inv(H)\nPolynomialRatio{:z, Float64}(LaurentPolynomial(0.3*z⁻¹ + 1.0), LaurentPolynomial(1.0))\n\njulia> H * H\nPolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))\n\njulia> H^2\nPolynomialRatio{:z, Float64}(LaurentPolynomial(1.0), LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0))\n\njulia> H^-2\nPolynomialRatio{:z, Float64}(LaurentPolynomial(0.09*z⁻² + 0.6*z⁻¹ + 1.0), LaurentPolynomial(1.0))\n","category":"page"},{"location":"filters/#stateful-filter-objects","page":"Filters - filter design and filtering","title":"Stateful filter objects","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DF2TFilter","category":"page"},{"location":"filters/#DSP.Filters.DF2TFilter","page":"Filters - filter design and filtering","title":"DSP.Filters.DF2TFilter","text":"DF2TFilter(coef[, si])\nDF2TFilter(coef[, sitype::Type])\n\nConstruct a stateful direct form II transposed filter with coefficients coef.\n\nOne can optionally specify as the second argument either\n\nsi, an array representing the initial filter state, or\nsitype, the eltype of a zeroed si\n\nThe initial filter state defaults to zeros if called with one argument.\n\nIf coef is a PolynomialRatio, Biquad, or SecondOrderSections, filtering is implemented directly. If coef is a ZeroPoleGain object, it is first converted to a SecondOrderSections object.\n\n\n\n\n\n","category":"type"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"DSP.jl's FIRFilter type maintains state between calls to filt, allowing you to filter a signal of indefinite length in RAM-friendly chunks. FIRFilter contains nothing more that the state of the filter, and a FIRKernel. There are five different kinds of FIRKernel for single rate, up-sampling, down-sampling, rational resampling, and arbitrary sample-rate conversion. You need not specify the type of kernel. The FIRFilter constructor selects the correct kernel based on input parameters.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"FIRFilter","category":"page"},{"location":"filters/#DSP.Filters.FIRFilter","page":"Filters - filter design and filtering","title":"DSP.Filters.FIRFilter","text":"FIRFilter(h[, ratio])\n\nConstruct a stateful FIRFilter object from the vector of filter taps h. ratio is an optional rational integer which specifies the input to output sample rate relationship (e.g. 147//160 for converting recorded audio from 48 KHz to 44.1 KHz).\n\n\n\n\n\nFIRFilter(h, rate[, Nϕ])\n\nReturns a polyphase FIRFilter object from the vector of filter taps h. rate is a floating point number that specifies the input to output sample-rate relationship fracfs_outfs_in. Nϕ is an optional parameter which specifies the number of phases created from h. Nϕ defaults to 32.\n\n\n\n\n\n","category":"type"},{"location":"filters/#Filter-application","page":"Filters - filter design and filtering","title":"Filter application","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"filt\nfilt!\nfiltfilt\nfftfilt\nfftfilt!\ntdfilt\ntdfilt!\nresample","category":"page"},{"location":"filters/#DSP.filt","page":"Filters - filter design and filtering","title":"DSP.filt","text":"filt(b, a, x, [si])\n\nApply filter described by vectors a and b to vector x, with an optional initial filter state vector si (defaults to zeros).\n\n\n\n\n\nfilt(f, x[, si])\n\nApply filter or filter coefficients f along the first dimension of array x. If f is a filter coefficient object, si is an optional array representing the initial filter state (defaults to zeros). If f is a PolynomialRatio, Biquad, or SecondOrderSections, filtering is implemented directly. If f is a ZeroPoleGain object, it is first converted to a SecondOrderSections object.  If f is a Vector, it is interpreted as an FIR filter, and a naïve or FFT-based algorithm is selected based on the data and filter length.\n\n\n\n\n\nfilt(f::DF2TFilter{<:FilterCoefficients{:z},<:Array{T}}, x::AbstractVector{V}) where {T,V}\n\nApply the stateful filter f on x.\n\nwarning: Warning\nThe output array has eltype promote_type(T, V), where T is the eltype of the filter state.For more control over the output type, provide a preallocated output array out to filt!(out, f, x).\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.filt!","page":"Filters - filter design and filtering","title":"DSP.filt!","text":"filt!(out, b, a, x, [si])\n\nSame as filt but writes the result into the out argument, which may alias the input x to modify it in-place.\n\n\n\n\n\nfilt!(out, f, x[, si])\n\nSame as filt() but writes the result into the out argument. Output array out may not be an alias of x, i.e. filtering may not be done in place.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.filtfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.filtfilt","text":"filtfilt(coef, x)\n\nFilter x in the forward and reverse directions using filter coefficients coef. The initial state of the filter is computed so that its response to a step function is steady state. Before filtering, the data is extrapolated at both ends with an odd-symmetric extension of length 3*(max(length(b), length(a))-1).\n\nBecause filtfilt applies the given filter twice, the effective filter order is twice the order of coef. The resulting signal has zero phase distortion.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.fftfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.fftfilt","text":"fftfilt(h, x)\n\nApply FIR filter taps h along the first dimension of array x using an FFT-based overlap-save algorithm.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.fftfilt!","page":"Filters - filter design and filtering","title":"DSP.Filters.fftfilt!","text":"fftfilt!(out, h, x)\n\nLike fftfilt but writes result into out array.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.tdfilt","page":"Filters - filter design and filtering","title":"DSP.Filters.tdfilt","text":"tdfilt(h, x)\n\nApply filter or filter coefficients h along the first dimension of array x using a naïve time-domain algorithm\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.tdfilt!","page":"Filters - filter design and filtering","title":"DSP.Filters.tdfilt!","text":"tdfilt!(out, h, x)\n\nLike tdfilt, but writes the result into array out. Output array out may not be an alias of x, i.e. filtering may not be done in place.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.resample","page":"Filters - filter design and filtering","title":"DSP.Filters.resample","text":"resample(x, rate[, coef])\n\nResample x at rational or arbitrary rate. coef is an optional vector of FIR filter taps. If coef is not provided, the taps will be computed using a Kaiser window.\n\nInternally, resample uses a polyphase FIRFilter object, but performs additional operations to make resampling a signal easier. It compensates for the FIRFilter's delay (ramp-up), and appends zeros to x. The result is that when the input and output signals are plotted on top of each other, they correlate very well, but one signal will have more samples than the other.\n\n\n\n\n\nresample(x::AbstractArray, rate::Real, h::Vector = resample_filter(rate); dims)\n\nResample an array x along dimension dims.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filter-design","page":"Filters - filter design and filtering","title":"Filter design","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Most analog and digital filters are constructed by composing response types, which determine the frequency response of the filter, with design methods, which determine how the filter is constructed.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"The response type is Lowpass, Highpass, Bandpass or Bandstop and includes the edges of the bands.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"The design method is Butterworth, Chebyshev1, Chebyshev2, Elliptic, or FIRWindow, and includes any necessary parameters for the method that affect the shape of the response, such as filter order, ripple, and attenuation.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Filter order estimation methods are available in buttord, cheb1ord, cheb2ord, and ellipord if the corner frequencies for different IIR filter types are known. remezord can be used for an initial FIR filter order estimate.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"analogfilter\ndigitalfilter","category":"page"},{"location":"filters/#DSP.Filters.analogfilter","page":"Filters - filter design and filtering","title":"DSP.Filters.analogfilter","text":"analogfilter(responsetype, designmethod)\n\nConstruct an analog filter. See below for possible response and filter types.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.digitalfilter","page":"Filters - filter design and filtering","title":"DSP.Filters.digitalfilter","text":"digitalfilter(responsetype, designmethod[; fs])\n\nConstruct a digital filter. See below for possible response and filter types.\n\n\n\n\n\n","category":"function"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"For some filters, the design method is more general or inherently implies a response type; these direct design methods include remez which designs equiripple FIR filters of all types, and iirnotch which designs a 2nd order \"biquad\" IIR notch filter.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"For a more general application of creating a digital filter from s-domain representation of an analog filter, one can use bilinear:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"bilinear","category":"page"},{"location":"filters/#DSP.Filters.bilinear","page":"Filters - filter design and filtering","title":"DSP.Filters.bilinear","text":"bilinear(f::FilterCoefficients{:s}, fs::Real)\n\nCalculate the digital filter (z-domain) ZPK representation of an analog filter defined in s-domain using bilinear transform with sampling frequency fs. The s-domain representation is first converted to a ZPK representation in s-domain and then transformed to z-domain using bilinear transform.\n\n\n\n\n\nbilinear(f::ZeroPoleGain{:s,Z,P,K}, fs::Real) where {Z,P,K}\n\nCalculate the digital filter (z-domain) ZPK representation of an analog filter defined as a ZPK representation in s-domain using bilinear transform with sampling frequency fs.\n\nInput s-domain representation must be a ZeroPoleGain{:s, Z, P, K} object:\n\nH(s) = fkfrac(s - verbfz1) ldots (s - verbfzm)(s - verbfp1) ldots (s - verbfpn)\n\nOutput z-domain representation is a ZeroPoleGain{:z, Z, P, K} object:\n\nH(z) = Kfrac(z - verbZ1) ldots (z - verbZm)(z - verbP1) ldots (z - verbPn)\n\nwhere Z, P, K are calculated as:\n\nZi = frac(2 + verbfziverbfs)(2 - verbfziverbfs) quad textfor  i = 1 ldots m\n\nPi = frac(2 + verbfpiverbfs)(2 - verbfpiverbfs) quad textfor  i = 1 ldots n\n\nK = fk  mathcalRe left fracprod_i=1^m (2*fs - fzi)prod_i=1^n (2*fs - fpi) right\n\nHere, m and n are respectively the numbers of zeros and poles in the s-domain representation. If m < n, then additional n-m zeros are added at z = -1.\n\n\n\n\n\n","category":"function"},{"location":"filters/#response-types","page":"Filters - filter design and filtering","title":"Filter response types","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Lowpass\nHighpass\nBandpass\nBandstop","category":"page"},{"location":"filters/#DSP.Filters.Lowpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Lowpass","text":"Lowpass(Wn)\n\nLow pass filter with cutoff frequency Wn.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Highpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Highpass","text":"Highpass(Wn)\n\nHigh pass filter with cutoff frequency Wn.\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Bandpass","page":"Filters - filter design and filtering","title":"DSP.Filters.Bandpass","text":"Bandpass(Wn1, Wn2)\n\nBand pass filter with pass band frequencies (Wn1, Wn2).\n\n\n\n\n\n","category":"type"},{"location":"filters/#DSP.Filters.Bandstop","page":"Filters - filter design and filtering","title":"DSP.Filters.Bandstop","text":"Bandstop(Wn1, Wn2)\n\nBand stop filter with stop band frequencies (Wn1, Wn2).\n\n\n\n\n\n","category":"type"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"The interpretation of the frequencies Wn, Wn1 and Wn2 depends on wether an analog or a digital filter is designed.","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"If an analog filter is designed using analogfilter, the frequencies are interpreted as analog frequencies in radians/second.\nIf a digital filter is designed using digitalfilter and the sampling frequency fs is specified, the frequencies of the filter response type are normalized to fs. This requires that the sampling frequency and the filter response type use the same frequency unit (Hz, radians/second, ...). If fs is not specified, the frequencies of the filter response type are interpreted as normalized frequencies in half-cycles/sample.","category":"page"},{"location":"filters/#design-methods","page":"Filters - filter design and filtering","title":"Filter design methods","text":"","category":"section"},{"location":"filters/#IIR-filter-design-methods","page":"Filters - filter design and filtering","title":"IIR filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Butterworth\nChebyshev1\nChebyshev2\nElliptic","category":"page"},{"location":"filters/#DSP.Filters.Butterworth","page":"Filters - filter design and filtering","title":"DSP.Filters.Butterworth","text":"Butterworth(n)\n\nn pole Butterworth filter.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Chebyshev1","page":"Filters - filter design and filtering","title":"DSP.Filters.Chebyshev1","text":"Chebyshev1(n, ripple)\n\nn pole Chebyshev type I filter with ripple dB ripple in the passband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Chebyshev2","page":"Filters - filter design and filtering","title":"DSP.Filters.Chebyshev2","text":"Chebyshev2(n, ripple)\n\nn pole Chebyshev type II filter with ripple dB ripple in the stopband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.Elliptic","page":"Filters - filter design and filtering","title":"DSP.Filters.Elliptic","text":"Elliptic(n, rp, rs)\n\nn pole elliptic (Cauer) filter with rp dB ripple in the passband and rs dB attentuation in the stopband.\n\n\n\n\n\n","category":"function"},{"location":"filters/#order-est-methods","page":"Filters - filter design and filtering","title":"Filter order estimation methods","text":"","category":"section"},{"location":"filters/#IIR-filter-order-estimation-methods","page":"Filters - filter design and filtering","title":"IIR filter order estimation methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"buttord\ncheb1ord\ncheb2ord\nellipord","category":"page"},{"location":"filters/#DSP.Filters.buttord","page":"Filters - filter design and filtering","title":"DSP.Filters.buttord","text":"(N, ωn) = buttord(Wp::Tuple{Real,Real}, Ws::Tuple{Real,Real}, Rp::Real, Rs::Real; domain=:z)\n\nButterworth order estimate for bandpass and bandstop filter types. Wp and Ws are 2-element pass and stopband frequency edges, with no more than Rp dB passband ripple and at least Rs dB stopband attenuation. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. N is an integer indicating the lowest estimated filter order, with ωn specifying the cutoff or \"-3 dB\" frequencies.\n\nIf a domain of :s is specified, the passband and stopband frequencies are interpreted as radians/second, giving an order and natural frequencies for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n(N, ωn) = buttord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain=:z)\n\nLPF/HPF Butterworth filter order and -3 dB frequency approximation. Wp and Ws are the passband and stopband frequencies, whereas Rp and Rs are the passband and stopband ripple attenuations in dB. If the passband is greater than stopband, the filter type is inferred to be for estimating the order of a highpass filter. N specifies the lowest possible integer filter order, whereas ωn is the cutoff or \"-3 dB\" frequency.\n\nIf a domain of :s is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.cheb1ord","page":"Filters - filter design and filtering","title":"DSP.Filters.cheb1ord","text":"(N, ωn) = cheb1ord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Chebyshev Type I Filters. Wp and Ws indicate the passband and stopband frequency edges, and Rp and Rs indicate the maximum loss in the passband and the minimum attenuation in the stopband, (in dB.)\n\nBased on the ordering of passband and stopband edges, the Lowpass or Highpass filter type is inferred. N indicates the smallest integer filter order that achieves the desired specifications, and ωn contains the natural frequency of the filter, (in this case, simply the passband edge.)\n\nIf a domain of :s is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n(N, ωn) = cheb1ord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Chebyshev Type I Filters. Wp and Ws are 2-element frequency edges for Bandpass/Bandstop cases, with Rp and Rs representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. N is an integer indicating the lowest estimated filter order, with ωn specifying the cutoff or \"-3 dB\" frequencies. If a domain of :s is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.cheb2ord","page":"Filters - filter design and filtering","title":"DSP.Filters.cheb2ord","text":"(N, ωn) = cheb2ord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Chebyshev Type II (inverse) Filters. Wp and Ws are the frequency edges for Bandpass/Bandstop cases, with Rp and Rs representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB.\n\nBased on the ordering of the passband and stopband edges, the Lowpass or Highpass filter type is inferred. N is an integer indicating the lowest estimated filter order, with ωn specifying the \"-3 dB\" cutoff frequency.\n\nIf a domain of :s is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n(N, ωn) = cheb2ord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Chebyshev Type II (inverse) Filters. Wp and Ws are 2-element frequency edges for Bandpass/Bandstop cases, with Rp and Rs representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB.\n\nBased on the ordering of the passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. N is an integer indicating the lowest estimated filter order, with ωn specifying the \"-3 dB\" cutoff frequency.\n\nIf a domain of :s is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.ellipord","page":"Filters - filter design and filtering","title":"DSP.Filters.ellipord","text":"(N, ωn) = ellipord(Wp::Real, Ws::Real, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Elliptic (Cauer) Filters. Wp and Ws indicate the passband and stopband frequency edges, and Rp and Rs indicate the maximum loss in the passband and the minimum attenuation in the stopband, (in dB.)\n\nBased on the ordering of passband and stopband edges, the Lowpass or Highpass filter type is inferred. N indicates the smallest integer filter order that achieves the desired specifications, and ωn contains the natural frequency of the filter, (in this case, simply the passband edge.)\n\nIf a domain of :s is specified, the passband and stopband edges are interpreted as radians/second, giving an order and natural frequency result for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n(N, ωn) = ellipord(Wp::Tuple{Real, Real}, Ws::Tuple{Real, Real}, Rp::Real, Rs::Real; domain::Symbol=:z)\n\nInteger and natural frequency order estimation for Elliptic (Cauer) Filters. Wp and Ws are 2-element frequency edges for Bandpass/Bandstop cases, with Rp and Rs representing the ripple maximum loss in the passband and minimum ripple attenuation in the stopband in dB. Based on the ordering of passband and bandstop edges, the Bandstop or Bandpass filter type is inferred. N is an integer indicating the lowest estimated filter order, with ωn specifying the cutoff or \"-3 dB\" frequencies. If a domain of :s is specified, the passband and stopband frequencies are interpreted as radians/second, giving the order and natural frequencies for an analog filter. The default domain is :z, interpreting the input frequencies as normalized from 0 to 1, where 1 corresponds to π radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#FIR-filter-order-estimation-methods","page":"Filters - filter design and filtering","title":"FIR filter order estimation methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"remezord","category":"page"},{"location":"filters/#DSP.Filters.remezord","page":"Filters - filter design and filtering","title":"DSP.Filters.remezord","text":"N = remezord(Wp, Ws, Rp, Rs)\n\nOrder estimation for lowpass digital filter cases based on the equations and coefficients in [Rabiner]. The original equation returned the minimum filter length, whereas this implementation returns the order (N=L-1). Wp and Ws are the normalized passband and stopband frequencies, with Rp indicating the passband ripple and Rs is the stopband attenuation (linear.)\n\nNOTE: The value of N is an initial approximation. If under-estimated, the order should be increased until the design specifications are met.\n\n[Rabiner]: Herrmann, O., Lawrence R. Rabiner, and D. S. K. Chan. \"Practical design rules for optimum finite impulse response lowpass digital filters.\" Bell System Technical Journal 52.6 (1973): 769-799.\n\n\n\n\n\n","category":"function"},{"location":"filters/#FIR-filter-design-methods","page":"Filters - filter design and filtering","title":"FIR filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"FIRWindow","category":"page"},{"location":"filters/#DSP.Filters.FIRWindow","page":"Filters - filter design and filtering","title":"DSP.Filters.FIRWindow","text":"FIRWindow(window; scale=true)\n\nFIR filter design using window window, a vector whose length matches the number of taps in the resulting filter.\n\nIf scale is true (default), the designed FIR filter is scaled so that the following holds:\n\nFor Lowpass and Bandstop filters, the frequency response is unity at 0 (DC).\nFor Highpass filters, the frequency response is unity at the Nyquist frequency.\nFor Bandpass filters, the frequency response is unity in the center of the passband.\n\n\n\n\n\nFIRWindow(; transitionwidth, attenuation=60, scale=true)\n\nKaiser window FIR filter design. The required number of taps is calculated based on transitionwidth (in half-cycles/sample) and stopband attenuation (in dB). attenuation defaults to 60 dB.\n\n\n\n\n\n","category":"type"},{"location":"filters/#direct-design-methods","page":"Filters - filter design and filtering","title":"Direct filter design methods","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"remez\niirnotch","category":"page"},{"location":"filters/#DSP.Filters.remez","page":"Filters - filter design and filtering","title":"DSP.Filters.remez","text":"remez(numtaps::Integer, band_defs;\n      Hz::Real=1.0,\n      neg::Bool=false,\n      maxiter::Integer=25,\n      grid_density::Integer=16)\n\nCalculate the minimax optimal filter using the Remez exchange algorithm [McClellan1973a] [McClellan1973b].\n\nThis is the simplified API that accepts just 2 required arguments (numtaps, band_defs). For a scipy compatible version see the 3 arguments version (numtaps, bands, desired).\n\nCalculate the filter-coefficients for the finite impulse response (FIR) filter whose transfer function minimizes the maximum error between the desired gain and the realized gain in the specified frequency bands using the Remez exchange algorithm.\n\nArguments\n\nnumtaps::Integer: The desired number of taps in the filter.   The number of taps is the number of terms in the filter, or the filter   order plus one.\nbands_defs: A sequence of band definitions.   This sequence defines the bands. Each entry is a pair. The pair's   first item is a tuple of band edges (low, high). The pair's second item   defines the desired response and weight in that band. The weight is optional   and defaults to 1.0. Both the desired response and weight may be either scalars   or functions. If a function, the function should accept a real frequency and   return the real desired response or real weight. Examples:\nLPF with unity weights. [(0, 0.475) => 1, (0.5, 1.0) => 0]\nLPF with weight of 2 in the stop band. [(0, 0.475) => (1, 1), (0.5, 1.0) => (0, 2)]\nBPF with unity weights. [(0, 0.375) => 0, (0.4, 0.5) => 1, (0.525, 1.0) => 0]\nHilbert transformer. [(0.1, 0.95) => 1]; neg=true\nDifferentiator. [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true\nHz::Real: The sampling frequency in Hz. Default is 1.\nneg::Bool: Whether the filter has negative symmetry or not. Default is false.   If false, the filter is even-symmetric. If true, the filter is odd-symmetric.   neg=true means that h[n]=-h[end+1-n]; neg=false means that h[n]=h[end+1-n].\nmaxiter::Integer: (optional)   Maximum number of iterations of the algorithm. Default is 25.\ngrid_density:Integer: (optional)   Grid density. The dense grid used in remez is of size   (numtaps + 1) * grid_density. Default is 16.\n\nReturns\n\nh::Array{Float64,1}: A rank-1 array containing the coefficients of the optimal   (in a minimax sense) filter.\n\n[McClellan1973a]: J. H. McClellan and T. W. Parks, A unified approach to the design of optimum FIR linear phase digital filters, IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.\n\n[McClellan1973b]: J. H. McClellan, T. W. Parks and L. R. Rabiner, A Computer Program for Designing Optimum FIR Linear Phase Digital Filters, IEEE Trans. Audio Electroacoust., vol. AU-21, pp. 506-525, 1973.\n\nExamples\n\nConstruct a length 35 filter with a passband at 0.15-0.4 Hz (desired response of 1), and stop bands at 0-0.1 Hz and 0.45-0.5 Hz (desired response of 0). Note: the behavior in the frequency ranges between those bands - the transition bands - is unspecified.\n\njulia> bpass = remez(35, [(0, 0.1)=>0, (0.15, 0.4)=>1, (0.45, 0.5)=>0]);\n\nYou can trade-off maximum error achieved for transition bandwidth. The wider the transition bands, the lower the maximum error in the bands specified. Here is a bandpass filter with the same passband, but wider transition bands.\n\njulia> bpass2 = remez(35, [(0, 0.08)=>0, (0.15, 0.4)=>1, (0.47, 0.5)=>0]);\n\nHere we compute the frequency responses and plot them in dB.\n\njulia> using PyPlot\njulia> b = DSP.Filters.PolynomialRatio(bpass, [1.0])\njulia> b2 = DSP.Filters.PolynomialRatio(bpass2, [1.0])\njulia> f = range(0, stop=0.5, length=1000)\njulia> plot(f, 20*log10.(abs.(freqresp(b,f,1.0))))\njulia> plot(f, 20*log10.(abs.(freqresp(b2,f,1.0))))\njulia> grid()\n\nExamples from the unittests - standard (even) symmetry.\n\nLength 151 LPF (Low Pass Filter).\n\njulia> h = remez(151, [(0, 0.475) => 1, (0.5, 1.0) => 0]; Hz=2.0);\n\nLength 152 LPF. Non-default \"weight\" input.\n\njulia> h = remez(152, [(0, 0.475) => (1, 1), (0.5, 1.0) => (0, 2)]; Hz=2.0);\n\nLength 51 HPF (High Pass Filter).\n\njulia> h = remez(51, [(0, 0.75) => 0, (0.8, 1.0) => 1]; Hz=2.0);\n\nLength 180 BPF (Band Pass Filter).\n\njulia> h = remez(180, [(0, 0.375) => 0, (0.4, 0.5) => 1, (0.525, 1.0) => 0]; Hz=2.0, maxiter=30);\n\nExamples from the unittests - Odd-symmetric filters - hilbert and differentiators type.\n\nEven length - has a much better approximation since the response is not constrained to 0 at the nyquist frequency.  Length 20 Hilbert transformer.\n\njulia> h = remez(20, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\nLength 21 Hilbert transformer.\n\njulia> h = remez(21, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\nLength 200 differentiator.\n\njulia> h = remez(200, [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\nLength 201 differentiator.\n\njulia> h = remez(201, [(0.05, 0.95) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\nInverse sinc filter - custom response function\n\njulia> L = 64; Fs = 4800*L;\njulia> passband_response_function = f -> (f==0) ? 1.0 : abs.((π*f/4800) ./ sin.(π*f/4800));\njulia> h = remez(201, [(    0.0, 2880.0) => (passband_response_function, 1.0),\n                (10000.0,   Fs/2) => (0.0, 100.0)]; Hz=Fs);\n\n\n\n\n\nremez(numtaps::Integer,\n      bands::Vector,\n      desired::Vector;\n      weight::Vector=[],\n      Hz::Real=1.0,\n      filter_type::RemezFilterType=filter_type_bandpass,\n      maxiter::Integer=25,\n      grid_density::Integer=16)\n\nThis is the scipy compatible version that requires 3 arguments (numtaps, bands, desired). For a simplified API, see the 2 argument version (numtaps, band_defs). The filters designed are equivalent, the inputs are just specified in a different way. Below the arguments and examples are described that differ from the simplified API version.\n\nArguments\n\nbands::Vector: A monotonic sequence containing the band edges in Hz.   All elements must be non-negative and less than half the sampling   frequency as given by Hz.\ndesired::Vector:A sequence half the size of bands containing the desired   gain in each of the specified bands.\nweight::Vector: (optional)   A relative weighting to give to each band region. The length of   weight has to be half the length of bands.\nfilter_type::RemezFilterType: Default is filter_type_bandpass.   The type of filter:\nfilter_type_bandpass : flat response in bands. This is the default.\nfilter_type_differentiator : frequency proportional response in bands.   Odd symetric as in filter_type_hilbert case, but with a linear sloping   desired response.\nfilter_type_hilbert : filter with odd symmetry, that is, type III             (for even order) or type IV (for odd order)             linear phase filters.\n\nExamples\n\nCompare the examples with the simplified API and the Scipy API. Each of the following blocks first designs a filter using the simplified (recommended) API, and then designs the same filter using the Scipy-compatible API.\n\njulia> bpass = remez(35, [(0, 0.1)=>0, (0.15, 0.4)=>1, (0.45, 0.5)=>0]);\n\njulia> bpass = remez(35, [0, 0.1, 0.15, 0.4, 0.45, 0.5], [0, 1, 0]);\n\n\njulia> bpass2 = remez(35, [(0, 0.08)=>0, (0.15, 0.4)=>1, (0.47, 0.5)=>0]);\n\njulia> bpass2 = remez(35, [0, 0.08, 0.15, 0.4, 0.47, 0.5], [0, 1, 0]);\n\n\njulia> h = remez(20, [(0.1, 0.95) => 1]; neg=true, Hz=2.0);\n\njulia> h = remez(20, [0.1, 0.95], [1]; filter_type=filter_type_hilbert, Hz=2.0);\n\n\njulia> h = remez(200, [(0.01, 0.99) => (f -> f/2, f -> 1/f)]; neg=true, Hz=2.0);\n\njulia> h = remez(200, [0.01, 0.99], [1]; filter_type=filter_type_differentiator, Hz=2.0);\n\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.iirnotch","page":"Filters - filter design and filtering","title":"DSP.Filters.iirnotch","text":"iirnotch(Wn, bandwidth[; fs])\n\nSecond-order digital IIR notch filter [Orfanidis] at frequency Wn with bandwidth bandwidth. If fs is not specified, Wn is interpreted as a normalized frequency in half-cycles/sample.\n\n[Orfanidis]: Orfanidis, S. J. (1996). Introduction to signal processing. Englewood Cliffs, N.J: Prentice Hall, p. 370.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filter-response","page":"Filters - filter design and filtering","title":"Filter response","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"freqresp\nphaseresp\ngrpdelay\nimpresp\nstepresp","category":"page"},{"location":"filters/#DSP.Filters.freqresp","page":"Filters - filter design and filtering","title":"DSP.Filters.freqresp","text":"H, w = freqresp(filter)\n\nFrequency response H of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\nfreqresp(filter::FilterCoefficients{:z}, w)\n\nFrequency response of digital filter at normalized frequency or frequencies w in radians/sample.\n\n\n\n\n\nfreqresp(filter::FilterCoefficients{:s}, w)\n\nFrequency response of analog filter at frequency or frequencies w in radians/second.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.phaseresp","page":"Filters - filter design and filtering","title":"DSP.Filters.phaseresp","text":"phi, w = phaseresp(filter)\n\nPhase response phi of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\nphaseresp(filter, w)\n\nPhase response of a filter at (normalized) frequency or frequencies w in radians/sample for a digital filter or radians/second for an analog filter.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.grpdelay","page":"Filters - filter design and filtering","title":"DSP.Filters.grpdelay","text":"tau, w = grpdelay(filter)\n\nGroup delay tau of a filter at (normalized) frequencies w in radians/sample for a digital filter or radians/second for an analog filter chosen as a reasonable default.\n\n\n\n\n\ngrpdelay(fliter, w)\n\nGroup delay of a digital 'filter' at normalized frequency or frequencies 'w' in radians/sample.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.impresp","page":"Filters - filter design and filtering","title":"DSP.Filters.impresp","text":"impresp(filter, n=100)\n\nImpulse response of a digital filter with n points.\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.stepresp","page":"Filters - filter design and filtering","title":"DSP.Filters.stepresp","text":"stepresp(filter, n=100)\n\nStep response of a digital filter with n points.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Miscellaneous","page":"Filters - filter design and filtering","title":"Miscellaneous","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"coefb\ncoefa","category":"page"},{"location":"filters/#DSP.Filters.coefb","page":"Filters - filter design and filtering","title":"DSP.Filters.coefb","text":"coefb(f)\n\nCoefficients of the numerator of a PolynomialRatio object, highest power first, i.e., the b passed to filt()\n\n\n\n\n\n","category":"function"},{"location":"filters/#DSP.Filters.coefa","page":"Filters - filter design and filtering","title":"DSP.Filters.coefa","text":"coefa(f)\n\nCoefficients of the denominator of a PolynomialRatio object, highest power first, i.e., the a passed to filt()\n\n\n\n\n\n","category":"function"},{"location":"filters/#Examples","page":"Filters - filter design and filtering","title":"Examples","text":"","category":"section"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Construct a 4th order elliptic lowpass filter with normalized cutoff frequency 0.2, 0.5 dB of passband ripple, and 30 dB attentuation in the stopband and extract the coefficients of the numerator and denominator of the transfer function:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Lowpass(0.2)\ndesignmethod = Elliptic(4, 0.5, 30)\ntf = convert(PolynomialRatio, digitalfilter(responsetype, designmethod))\nnumerator_coefs = coefb(tf)\ndenominator_coefs = coefa(tf)","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Filter the data in x, sampled at 1000 Hz, with a 4th order Butterworth bandpass filter between 10 and 40 Hz:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Bandpass(10, 40)\ndesignmethod = Butterworth(4)\nfilt(digitalfilter(responsetype, designmethod; fs=1000), x)","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Filter the data in x, sampled at 50 Hz, with a 64 tap Hanning window FIR lowpass filter at 5 Hz:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"responsetype = Lowpass(5)\ndesignmethod = FIRWindow(hanning(64))\nfilt(digitalfilter(responsetype, designmethod; fs=50), x)","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"Estimate a Lowpass Elliptic filter order with a normalized passband cutoff frequency of 0.2, a stopband cutoff frequency of 0.4, 3 dB of passband ripple, and 40 dB attenuation in the stopband:","category":"page"},{"location":"filters/","page":"Filters - filter design and filtering","title":"Filters - filter design and filtering","text":"(N, ωn) = ellipord(0.2, 0.4, 3, 40)","category":"page"},{"location":"lpc/#LPC-Linear-Predictive-Coding","page":"LPC - Linear Predictive Coding","title":"LPC - Linear Predictive Coding","text":"","category":"section"},{"location":"lpc/","page":"LPC - Linear Predictive Coding","title":"LPC - Linear Predictive Coding","text":"lpc\narburg\nlevinson","category":"page"},{"location":"lpc/#DSP.LPC.lpc","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.lpc","text":"lpc(x::AbstractVector, p::Integer, [LPCBurg()])\n\nGiven input signal x and prediction order p, returns IIR coefficients a and average reconstruction error prediction_err. Note that this method does NOT return the leading 1 present in the true autocorrelative estimate; it omits it as it is implicit in every LPC estimate, and must be manually reintroduced if the returned vector should be treated as a polynomial.\n\nThe algorithm used is determined by the last optional parameter, and can be either LPCBurg (arburg) or LPCLevinson (levinson).\n\n\n\n\n\n","category":"function"},{"location":"lpc/#DSP.LPC.arburg","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.arburg","text":"arburg(x::AbstractVector, p::Integer)\n\nLPC (Linear Predictive Coding) estimation, using the Burg method. This function implements the mathematics published in [Lagrange], and the recursion relation as noted in [Vos], in turn referenced from [Andersen].\n\n[Lagrange]: Enhanced Partial Tracking Using Linear Prediction. DAFX 2003 article, Lagrange et al\n\n[Vos]: A Fast Implementation of Burg’s Method. © 2013 Koen Vos, licensed under CC BY 3.0\n\n[Andersen]: N. Andersen. Comments on the performance of maximum entropy algorithms. Proceedings of the IEEE 66.11: 1581-1582, 1978.\n\n\n\n\n\n","category":"function"},{"location":"lpc/#DSP.LPC.levinson","page":"LPC - Linear Predictive Coding","title":"DSP.LPC.levinson","text":"levinson(x::AbstractVector, p::Integer)\n\nImplements Levinson recursion, as described in [Levinson], to find the solution a of the linear equation\n\nmathbfT (-veca)\n=\nbeginbmatrix\n    x_2 \n    vdots \n    x_p+1\nendbmatrix\n\nin the case where mathbfT is Hermitian and Toeplitz, with first column x[1:p]. This function can be used for LPC (Linear Predictive Coding) estimation, by providing LPCLevinson() as an argument to lpc.\n\n[Levinson]: The Wiener (RMS) Error Criterion in Filter Design and Prediction. N. Levinson, Studies in Applied Mathematics 25(1946), 261-278.\nhttps://doi.org/10.1002/sapm1946251261\n\n\n\n\n\n","category":"function"},{"location":"#Welcome-to-DSP.jl's-documentation!","page":"Home","title":"Welcome to DSP.jl's documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DSP.jl provides a number of common digital signal processing routines in Julia. So far, the following submodules are implemented:","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"periodograms.md\",\n    \"estimation.md\",\n    \"windows.md\",\n    \"filters.md\",\n    \"util.md\",\n    \"convolutions.md\",\n    \"lpc.md\",\n    \"internals.md\",\n    \"appendix.md\"\n]","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Functions here are not exported.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"DSP.os_fft_complexity\nDSP.os_prepare_conv\nDSP.os_conv_block!\nDSP.os_filter_transform!\nDSP.Windows.makewindow\nDSP.Windows.padplot\nDSP._zeropad\nDSP._zeropad!\nDSP._zeropad_keep_offset\nDSP.Filters.freq_eval\nDSP.Filters.build_grid\nDSP.Filters.lagrange_interp\nDSP.Periodograms.coherence_from_cs!\nDSP.optimalfftfiltlength","category":"page"},{"location":"internals/#DSP.os_fft_complexity","page":"Internals","title":"DSP.os_fft_complexity","text":"Estimate the number of floating point multiplications per output sample for an overlap-save algorithm with fft size nfft, and filter size nb.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.os_prepare_conv","page":"Internals","title":"DSP.os_prepare_conv","text":"Prepare buffers and FFTW plans for convolution. The two buffers, tdbuff and fdbuff may be an alias of each other, because complex convolution only requires one buffer. The plans are mutating where possible, and the inverse plan is unnormalized.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.os_conv_block!","page":"Internals","title":"DSP.os_conv_block!","text":"Take a block of data, and convolve it with the smaller convolution input. This may modify the contents of tdbuff and fdbuff, and the result will be in tdbuff.\n\n\n\n\n\nLike the real version, but only operates on one buffer\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.os_filter_transform!","page":"Internals","title":"DSP.os_filter_transform!","text":"Transform the smaller convolution input to frequency domain, and return it in a new array. However, the contents of buff may be modified.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Windows.makewindow","page":"Internals","title":"DSP.Windows.makewindow","text":"makewindow(winfunc::Function, n::Integer, padding::Integer, zerophase::Bool)\n\nGenerate a discrete window vector of the given length with padding zeros. winfunc should be a function giving the window value in the range of [-0.5, 0.5]. The function is assumed to be 0 outside of this range.\n\nIf zerophase is false (the default) the window is centered around index (n+1)/2, which is commonly used for FIR filter design. These are often used for FIR filter design, and usually odd-length. Note that for even-length windows this will cause the window center to be located between samples.\n\nIf zerophase is true the window is centered around index 1 (with the negative half wrapped to the end of the vector). Additionally this creates a \"periodic\" window, which means that if there is no padding then the left and right endpoints of the window wrap around to the same sample, so the window length is the same as an n+1-length non-zerophase window. Alternatively you can think of the continuous zerophase window being of width n and the non-zerophase window being of length n-1. zerophase windows are often used in FFT processing, and are usually even-length.\n\nExample:\n\nfunction hanning(n::Integer; padding::Integer=0, zerophase::Bool=false)\n    makewindow(n, padding, zerophase) do x\n        0.5*(1+cos(2pi*x))\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Windows.padplot","page":"Internals","title":"DSP.Windows.padplot","text":"padplot(plotstr)\n\nTakes a multiline string and pre-pads it so that it shows up as preformatted code when included in a docstring.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP._zeropad","page":"Internals","title":"DSP._zeropad","text":"_zeropad(u, padded_size, [data_dest, data_region])\n\nCreates and returns a new base-1 index array of size padded_size, with the section of u specified by data_region copied into the region of the new  array as specified by data_dest. All other values will be initialized to  zero.\n\nIf either data_dest or data_region is not specified, then the defaults described in _zeropad! will be used.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP._zeropad!","page":"Internals","title":"DSP._zeropad!","text":"_zeropad!(padded::AbstractVector,\n          u::AbstractVector,\n          padded_axes = axes(padded),\n          data_dest::Tuple = (1,),\n          data_region = CartesianIndices(u))\n\nPlace the portion of u specified by data_region into padded, starting at location data_dest. Sets the rest of padded to zero. This will mutate padded. padded_axes must correspond to the axes of padded.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP._zeropad_keep_offset","page":"Internals","title":"DSP._zeropad_keep_offset","text":"_zeropad_keep_offset(u, padded_size, [data_dest, dat_region])\n\nLike _zeropad, but retains the first index of u when creating a new array.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Filters.freq_eval","page":"Internals","title":"DSP.Filters.freq_eval","text":"function freq_eval(xf, x::AbstractVector, y::AbstractVector, ad::AbstractVector)\n\n\n\nFUNCTION: freq_eval (gee)   FUNCTION TO EVALUATE THE FREQUENCY RESPONSE USING THE   LAGRANGE INTERPOLATION FORMULA IN THE BARYCENTRIC FORM\n\n\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Filters.build_grid","page":"Internals","title":"DSP.Filters.build_grid","text":"build_grid(numtaps, band_defs, Hz, grid_density, neg)\n\nReturns grid, des, and wt arrays\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Filters.lagrange_interp","page":"Internals","title":"DSP.Filters.lagrange_interp","text":"lagrange_interp(k::Integer, n::Integer, m::Integer, x::AbstractVector)\n\nCALCULATE THE LAGRANGE INTERPOLATION COEFFICIENTS\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.Periodograms.coherence_from_cs!","page":"Internals","title":"DSP.Periodograms.coherence_from_cs!","text":"coherence_from_cs!(output::AbstractArray, cs_matrix)\n\nCompute the pairwise channel coherences from a cross spectral matrix, storing the result in output.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DSP.optimalfftfiltlength","page":"Internals","title":"DSP.optimalfftfiltlength","text":"Determine the length of FFT that minimizes the number of multiplications per output sample for an overlap-save convolution of vectors of size nb and nx.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Periodograms-periodogram-estimation","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"","category":"section"},{"location":"periodograms/#Basic-functions","page":"Periodograms - periodogram estimation","title":"Basic functions","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"Common procedures like computing the short-time Fourier transform, periodograms, and spectrograms are documented below.","category":"page"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"arraysplit\nperiodogram(s::AbstractVector{T}) where T <: Number\nwelch_pgram\nwelch_pgram!\nspectrogram\nstft\nperiodogram(s::AbstractMatrix{T}) where T <: Real\nfreq\npower\ntime\ncoherence\nDSP.Periodograms.Coherence","category":"page"},{"location":"periodograms/#DSP.Periodograms.arraysplit","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.arraysplit","text":"arraysplit(s, n, m, nfft=n, window=nothing; buffer=zeros(eltype(s), nfft))\n\nSplit an array into arrays of length n with overlapping regions of length m. Iterating or indexing the returned AbstractVector always yields the same Vector with different contents. Optionally provide a buffer of length nfft\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.periodogram-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Number","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.periodogram","text":"periodogram(s; onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes periodogram of a signal by FFT and returns a Periodogram object.\n\nFor real signals, the two-sided periodogram is symmetric and this function returns a one-sided (real only) periodogram by default. A two-sided periodogram can be obtained by setting onesided=false.\n\nnfft specifies the number of points to use for the Fourier transform. If length(s) < nfft, then the input is padded with zeros. By default, nfft is the closest size for which the Fourier transform can be computed with maximal efficiency.\n\nfs is the sample rate of the original signal, and window is an optional window function or vector to be applied to the original signal before computing the Fourier transform. The computed periodogram is normalized so that the area under the periodogram is equal to the uncentered variance (or average power) of the original signal.\n\n\n\n\n\n","category":"method"},{"location":"periodograms/#DSP.Periodograms.welch_pgram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.welch_pgram","text":"welch_pgram(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real,\n            nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the Welch periodogram of a signal s based on segments with n samples with overlap of noverlap samples, and returns a Periodogram object. For a Bartlett periodogram, set noverlap=0. See periodogram for description of optional keyword arguments.\n\n\n\n\n\nwelch_pgram(signal::AbstractVector, config::WelchConfig)\n\nComputes the Welch periodogram of the given signal using a predefined WelchConfig object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.welch_pgram!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.welch_pgram!","text":"welch_pgram!(out::AbstractVector, in::AbstractVector, n=div(length(s), 8),\n             noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n),\n             fs=1, window=nothing)\n\nComputes the Welch periodogram of a signal s, storing the result in out, based on segments with n samples with overlap of noverlap samples, and returns a Periodogram object. For a Bartlett periodogram, set noverlap=0. See periodogram for description of optional keyword arguments.\n\n\n\n\n\nwelch_pgram!(out::AbstractVector, in::AbstractVector, config::WelchConfig)\n\nComputes the Welch periodogram of the given signal, storing the result in out, using a predefined WelchConfig object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.spectrogram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.spectrogram","text":"spectrogram(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the spectrogram of a signal s based on segments with n samples with overlap of noverlap samples, and returns a Spectrogram object. See periodogram for description of optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.stft","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.stft","text":"stft(s, n=div(length(s), 8), noverlap=div(n, 2); onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, window=nothing)\n\nComputes the STFT of a signal s based on segments with n samples with overlap of noverlap samples, and returns a matrix containing the STFT coefficients. See periodogram for description of optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.periodogram-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.periodogram","text":"periodogram(s::AbstractMatrix; nfft=nextfastfft(size(s)), fs=1, radialsum=false, radialavg=false)\n\nComputes periodogram of a 2-d signal by FFT and returns a Periodogram2 object.\n\nReturns a 2-d periodogram by default. A radially summed or averaged periodogram is returned as a Periodogram object if radialsum or  radialavg is true, respectively.\n\nnfft specifies the number of points to use for the Fourier transform. If size(s) < nfft, then the input is padded with zeros. By default, nfft is the closest size for which the Fourier transform can be computed with maximal efficiency. fs is the sample rate of the original signal in both directions.\n\nFor radialsum=true the value of power[k] is proportional to frac1Nsum_kleq kk+1 Xk^2. For radialavg=true it is proportional to frac1N kleq kk+1 sum_kleq kk+1 Xk^2. The computation of |k'| takes into account non-square signals by scaling the coordinates of the wavevector accordingly.\n\n\n\n\n\n","category":"method"},{"location":"periodograms/#DSP.Periodograms.freq","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.freq","text":"freq(p)\n\nReturns the frequency bin centers for a given Periodogram, Spectrogram, CrossPowerSpectra, or Coherence object.\n\nReturns a tuple of frequency bin centers for a given Periodogram2 object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.power","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.power","text":"power(p)\n\nFor a Periodogram, returns the computed power at each frequency as a Vector.\n\nFor a Spectrogram, returns the computed power at each frequency and time bin as a Matrix. Dimensions are frequency × time.\n\nFor a CrossPowerSpectra, returns the pairwise power between each pair of channels at each frequency. Dimensions are channel x channel x frequency.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Base.Libc.time","page":"Periodograms - periodogram estimation","title":"Base.Libc.time","text":"time(p)\n\nReturns the time bin centers for a given Spectrogram object.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.coherence","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.coherence","text":"coherence(c::Coherence)\n\nGiven an Coherence object, returns an n_channels x n_channels x length(freq(c)) array consisting of the pairwise coherences between each channel for each frequency.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.Coherence","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.Coherence","text":"Coherence{T, F, A<:AbstractArray{T, 3}}\n\nHolds an n_channels x n_channels x length(freq) array consisting of the pairwise coherences between each channel for each frequency which is accessed by coherence, as well as the frequencies accessed by freq.\n\nSee also mt_coherence and mt_coherence!.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#Multitaper-periodogram-estimation","page":"Periodograms - periodogram estimation","title":"Multitaper periodogram estimation","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"mt_pgram\nmt_pgram!\nmt_spectrogram\nmt_spectrogram!\nmt_cross_power_spectra\nmt_cross_power_spectra!\nDSP.Periodograms.CrossPowerSpectra\nmt_coherence\nmt_coherence!","category":"page"},{"location":"periodograms/#DSP.Periodograms.mt_pgram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_pgram","text":"mt_pgram(s; onesided=eltype(s)<:Real, nfft=nextfastfft(n), fs=1, nw=4, ntapers=iceil(2nw)-1, window=dpss(length(s), nw, ntapers))\nmt_pgram(signal::AbstractVector, config::MTConfig)\n\nComputes the multitaper periodogram of a signal s.\n\nIf window is not specified, the signal is tapered with ntapers discrete prolate spheroidal sequences with time-bandwidth product nw. Each sequence is equally weighted; adaptive multitaper is not (yet) supported.\n\nIf window is specified, each column is applied as a taper. The sum of periodograms is normalized by the total sum of squares of window.\n\nReturns a Periodogram.\n\nSee also mt_pgram! and MTConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_pgram!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_pgram!","text":"mt_pgram!(output, s::AbstractVector{T}; onesided::Bool=eltype(s)<:Real,\n    nfft::Int=nextfastfft(length(s)), fs::Real=1,\n    nw::Real=4, ntapers::Int=ceil(Int, 2nw)-1,\n    window::Union{AbstractMatrix,Nothing}=nothing) where T<:Number\nmt_pgram!(output::AbstractVector, signal::AbstractVector, config::MTConfig) -> Periodogram\n\nComputes a multitapered periodogram, storing the output in output. Arguments:\n\nsignal::AbstractVector: should be of length config.n_samples\noutput::AbstractVector: should be of length length(config.freq)\n\nOptionally pass an MTConfig object to preallocate temporary variables and choose configuration settings; otherwise, keyword arguments may be passed to choose those settings.\n\nReturns a Periodogram.\n\nSee also mt_pgram and MTConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_spectrogram","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_spectrogram","text":"mt_spectrogram(signal::AbstractVector{T}, n::Int=length(s) >> 3,\n                              n_overlap::Int=n >> 1; fs=1,\n                              onesided::Bool=T <: Real, kwargs...) where {T}\nmt_spectrogram(signal::AbstractVector, config::MTSpectrogramConfig)\n\nCompute a multitaper spectrogram, returning a Spectrogram object. Optionally pass a MTSpectrogramConfig object; otherwise, any additional keyword arguments accepted by MTConfig may be passed to configure the tapering.\n\nReturns a Spectrogram.\n\nSee also mt_spectrogram!.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_spectrogram!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_spectrogram!","text":"mt_spectrogram!(output, signal::AbstractVector{T}, n::Int=length(signal) >> 3,\n    n_overlap::Int=n >> 1; fs=1, onesided::Bool=T <: Real, kwargs...) where {T}\nmt_spectrogram!(destination::AbstractMatrix, signal::AbstractVector, config::MTSpectrogramConfig)\n\nComputes a multitaper spectrogram using the parameters specified in config. Arguments:\n\ndestination: length(config.mt_config.freq) x length(config.time) matrix. This can be created by DSP.allocate_output(config).\nsignal: vector of length config.n_samples\nconfig: optionally, pass an MTSpectrogramConfig object to hold temporary variables and configuration settings. Otherwise, settings arguments may be passed directly.\n\nReturns a Spectrogram.\n\nSee also mt_spectrogram.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_cross_power_spectra","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_cross_power_spectra","text":"mt_cross_power_spectra(signal::AbstractMatrix{T}; fs=1, kwargs...) where {T}\nmt_cross_power_spectra(signal::AbstractMatrix, config::MTCrossSpectraConfig)\n\nComputes multitapered cross power spectra between channels of a signal. Arguments:\n\nsignal: n_channels x n_samples\nOptionally pass an MTCrossSpectraConfig object to preallocate temporary variables\n\nand choose configuration settings. Otherwise, any keyword arguments accepted by MTCrossSpectraConfig may be passed here.\n\nProduces a CrossPowerSpectra object holding the n_channels x n_channels x n_frequencies output array (accessed by power) and the corresponding frequencies (accessed by freq).\n\nSee also mt_cross_power_spectra! and MTCrossSpectraConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_cross_power_spectra!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_cross_power_spectra!","text":"mt_cross_power_spectra!(output, signal::AbstractMatrix; fs=1, kwargs...)\nmt_cross_power_spectra!(output, signal::AbstractMatrix, config::MTCrossSpectraConfig)\n\nComputes multitapered cross power spectra between channels of a signal. Arguments:\n\noutput: n_channels x n_channels x length(config.freq). Can be created by DSP.allocate_output(config).\nsignal: n_channels x n_samples\nconfig: MTCrossSpectraConfig{T}: optionally pass a MTCrossSpectraConfig to preallocate temporary and choose configuration settings. Otherwise, one may pass any keyword arguments accepted by this object.\n\nProduces a CrossPowerSpectra object holding the n_channels x n_channels x n_frequencies output array and the corresponding frequencies (accessed by freq).\n\nSee also mt_cross_power_spectra and MTCrossSpectraConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.CrossPowerSpectra","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.CrossPowerSpectra","text":"CrossPowerSpectra{T,F,A<:AbstractArray{T, 3}}\n\nAccess the power (an n_channels x n_channels x length(freq) array) via the function power, and the frequencies by the function freq.\n\nSee also mt_cross_power_spectra and mt_cross_power_spectra!.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.mt_coherence","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_coherence","text":"mt_coherence(signal::AbstractMatrix{T}; fs=1, freq_range = nothing, demean=false, kwargs...) where T\nmt_coherence(signal::AbstractMatrix, config::MTCoherenceConfig)\n\nArguments:\n\nsignal: n_channels x n_samples matrix\nOptionally pass an MTCoherenceConfig to pre-allocate temporary variables and choose configuration settings, otherwise, see MTCrossSpectraConfig for the meaning of the keyword arguments.\n\nReturns a Coherence object.\n\nSee also mt_coherence and MTCoherenceConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#DSP.Periodograms.mt_coherence!","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.mt_coherence!","text":"mt_coherence!(output, signal::AbstractMatrix; fs=1, freq_range=nothing, demean=false, kwargs...)\nmt_coherence!(output, signal::AbstractMatrix, config::MTCoherenceConfig)\n\nComputes the pairwise coherences between channels.\n\noutput: n_channels x n_channels matrix\nsignal: n_samples x n_channels matrix\nconfig: optional configuration object that pre-allocates temporary variables and choose settings.\n\nReturns a Coherence object.\n\nSee also mt_coherence and MTCoherenceConfig.\n\n\n\n\n\n","category":"function"},{"location":"periodograms/#Configuration-objects","page":"Periodograms - periodogram estimation","title":"Configuration objects","text":"","category":"section"},{"location":"periodograms/","page":"Periodograms - periodogram estimation","title":"Periodograms - periodogram estimation","text":"WelchConfig\nMTConfig\nMTSpectrogramConfig\nMTCrossSpectraConfig\nMTCoherenceConfig","category":"page"},{"location":"periodograms/#DSP.Periodograms.WelchConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.WelchConfig","text":"WelchConfig(data; n=size(signal, ndims(signal))>>3, noverlap=n>>1,\n         onesided=eltype(signal)<:Real, nfft=nextfastfft(n),\n         fs=1, window=nothing)\n\nWelchConfig(nsamples, eltype; n=nsamples>>3, noverlap=n>>1,\n         onesided=eltype<:Real, nfft=nextfastfft(n),\n         fs=1, window=nothing)\n\nCaptures all configuration options for welch_pgram in a single struct (akin to MTConfig). When passed on the second argument of welch_pgram, computes the periodogram based on segments with n samples with overlap of noverlap samples, and returns a Periodogram object. For a Bartlett periodogram, set noverlap=0. See periodogram for description of optional keyword arguments.\n\nnote: Note\nWelchConfig precomputes an fft plan, and preallocates the necessary intermediate buffers. Thus, repeated calls to welch_pgram that use the same WelchConfig object will be more efficient than otherwise possible.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTConfig","text":"MTConfig{T}(n_samples; fs=1,\n        nfft = nextpow(2, n_samples),\n        window = nothing,\n        nw = 4,\n        ntapers = 2 * nw - 1,\n        taper_weights = fill(1/ntapers, ntapers),\n        onesided::Bool=T<:Real,\n        fft_flags = FFTW.MEASURE)\n\nCreates a config object which holds the configuration state and temporary variables used in multitaper computations, e.g. mt_pgram!, mt_spectrogram, MTSpectrogramConfig, MTCrossSpectraConfig, and MTCoherenceConfig.\n\nAn MTConfig can be re-used between computations as long as none of the input arguments change.\n\nn_samples: the number of samples to be used as input when computing multitaper periodograms with this configuration. Used for pre-allocating temporary buffers.\nfs: the number of samples per second of the input signal\nnfft: length of input vector to the FFT; if nfft > n_samples, then the input signal will be zero-padded until it is of length nfft.\nwindow: window function to use for tapering. If left at the default of nothing, window will be set to dpss(n_samples, nw, ntapers).\nntapers: the number of tapers to use.\ntaper_weights = fill(1/ntapers, ntapers): how to weight the contribution of each taper. The default setting is to simply average them.\nonesided: whether or not to compute a \"one-sided\" FFT by using that real signal data yields conjugate-symmetry in Fourier space.\nfft_flags: flags to control how the FFT plan is generated.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTSpectrogramConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTSpectrogramConfig","text":"MTSpectrogramConfig(n_samples, mt_config::MTConfig{T}, n_overlap_samples) where {T}\nMTSpectrogramConfig{T}(n_samples, samples_per_window, n_overlap_samples; fs=1, kwargs...) where {T}\n\nCreates a MTSpectrogramConfig which holds configuration and temporary variables for mt_spectrogram and mt_spectrogram!. Any keyword arguments accepted by MTConfig may be passed here, or an MTConfig object itself.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTCrossSpectraConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTCrossSpectraConfig","text":"MTCrossSpectraConfig{T}(n_channels, n_samples; fs=1, demean=false, freq_range=nothing,\n                        ensure_aligned = T == Float32 || T == Complex{Float32}, kwargs...) where {T}\nMTCrossSpectraConfig(n_channels, mt_config::MTConfig{T}; demean=false, freq_range=nothing,\n                     ensure_aligned = T == Float32 || T == Complex{Float32})\n\nCreates a configuration object used for mt_cross_power_spectra and mt_cross_power_spectra!.\n\nn_channels: the number of channels of the input.\nn_samples: the number of samples for each channel of the input.\ndemean: if true, the channelwise mean will be subtracted from the input signals before the cross spectral powers are computed.\nfreq_range: if nothing, all frequencies are retained. Otherwise, only frequencies between first(freq_range) and last(freq_range) are retained.\nensure_aligned = T == Float32 || T == Complex{Float32}: perform an extra copy to ensure that the FFT output is memory-aligned\nAdditionally, either pass an MTConfig object, or keyword arguments such as fs accepted by MTConfig.\n\nReturns a CrossPowerSpectra object.\n\n\n\n\n\n","category":"type"},{"location":"periodograms/#DSP.Periodograms.MTCoherenceConfig","page":"Periodograms - periodogram estimation","title":"DSP.Periodograms.MTCoherenceConfig","text":"MTCoherenceConfig{T}(n_channels, n_samples; fs=1, demean=false, freq_range=nothing, kwargs...) where T\nMTCoherenceConfig(cs_config::MTCrossSpectraConfig{T}) where {T}\nMTCoherenceConfig(n_channels, mt_config::MTConfig{T}; demean=false, freq_range=nothing,\n    ensure_aligned = T == Float32 || T == Complex{Float32}) where {T}\n\nCreates a configuration object for coherences from a MTCrossSpectraConfig. Provides a helper method with the same arugments as MTCrossSpectraConfig to construct the MTCrossSpectraConfig object.\n\nSee also mt_coherence and mt_coherence!.\n\n\n\n\n\n","category":"type"}]
}
